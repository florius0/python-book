# 15. Модули и пакеты

В Python модули - это просто файлы с расширением `.py` (до сих пор мы не обращали на это внимание).
Модули могут быть импортированы в другие модули или в интерактивную оболочку интерпретатора.

Так же, они могут быть исполнены напрямую (мы уже делали это в 3ей главе): `python3 mymodule.py`.

## 1. Импорт модуля

Для импорта модуля используется инструкция `import`.

Важно отметить, что модуль импортируется только один раз, даже если инструкция `import` повторяется в коде.

При импорте модуля Python ищет файл модуля в следующих местах:

1. Директория, в которой запущен интерпретатор, или в которой расположен текущий выполняемый модуль.
2. Модули по путям, указанным в переменной окружения `PYTHONPATH` (синтаксис такой же, как и в `PATH`).
3. Путь инсталляции Python (например, `/usr/lib/python3.5`), включая сторонние библиотеки.

Для дальнейших примеров создадим файл `mymodule.py` со следующим содержимым:

<!--
filename: chapter_14/mymodule.md
-->

```python
def say_hello():
    print("Hello, world!")

def say_goodbye():
    print("Goodbye, world!")
```

Существует несколько вариантов использования `import`:

### 1. Импорт модуля целиком

<!--
filename: chapter_14/import_whole_module.py
-->
```python
import mymodule

mymodule.say_hello()
```

В этом случае мы импортируем модуль целиком и обращаемся к содержимому модуля используя его имя.

### 2. Импорт модуля под другим именем (алиасинг)

<!--
filename: chapter_14/import_module_with_alias.py
-->
```python
#      Имя модуля
#      |           Имя, под которым будет доступен модуль
#      |           |
import mymodule as mm

mm.say_hello()
```

В этом случае мы импортируем модуль целиком и обращаемся к содержимому модуля используя алиас (новое имя модуля).

### 3. Импорт конкретного класса/функции/переменной из модуля

<!--
filename: chapter_14/import_one_from_module.py
-->
```python
#    Имя модуля
#    |               Имя класса/функции/переменной
#    |               |
from mymodule import say_hello

say_hello()
```

В этом случае мы импортируем только указанные классы/функции/переменные и обращаемся к ней напрямую.

Для того, чтобы импортировать несколько классов/функций/переменных, их нужно перечислить через запятую.

<!--
filename: chapter_14/import_several_from_module.py
-->
```python
#    Имя модуля
#    |               Имя класса/функции/переменной
#    |               |          Имя класса/функции/переменной
#    |               |          |
from mymodule import say_hello, say_goodbye

say_hello()
say_goodbye()
```

Так же, мы можем импортировать все классы/функции/переменные из модуля, используя звездочку `*` в качестве имени импортируемого объекта:

<!--
filename: chapter_14/import_all_from_module.py
-->
```python
#    Имя модуля
#    |
#    |
from mymodule import *

say_hello()
say_goodbye()
```

## 2. Переменная `__name__`

Каждый модуль в Python имеет своё имя. Это имя можно получить с помощью переменной `__name__`.
Если модуль запущен, то `__name__` будет равен `__main__`. Если модуль импортирован, то `__name__` будет равен имени модуля.

При импорте модуля в другой модуль, код модуля, который импортируется, выполняется. Поэтому, если мы хотим, чтобы код модуля выполнялся только при запуске модуля, а не при импорте, то нужно проверять значение переменной `__name__`.

Проиллюстрируем это на примере. Создадим два модуля: `no_name_check и name_check`. В первом модуле мы определим и вызовем функцию, а во втором модуле мы проверим значение переменной `__name__` и вызовем функцию только если оно равно `__main__`.

<!--
filename: chapter_14/no_name_check.py
-->

```python
# no_name_check.py
def fib(n):
    a, b = 0, 1
    while a < n:
        a, b = b, a + b

    return a

print(fib(100))
```

<!--
filename: chapter_14/name_check.py
-->

```python
# name_check.py
def fib(n):
    a, b = 0, 1
    while a < n:
        a, b = b, a + b

    return a

if __name__ == '__main__':
    print(fib(100))
```

Теперь запустим модуль `no_name_check.py`:

<!--
runs: chapter_14/no_name_check.py
stdout: |
    144
-->

```bash
$ python3 no_name_check.py
144
```

Все хорошо, функция `fib` вызвалась и мы получили результат. А теперь импортируем этот модуль и запустим программу:

<!--
filename: chapter_14/import_no_name_check.py
-->

```python
from no_name_check import fib

print(fib(500))
```

<!--
runs: chapter_14/import_no_name_check.py
stdout: |
    144
    610
-->

```bash
$ python3 import_no_name_check.py
144
610
```

Видим, что функция `fib` вызвалась дважды. Это произошло потому, что при импорте модуля, код модуля выполняется. Поэтому, чтобы функция `fib` вызывалась только при запуске модуля, а не при импорте, нужно проверять значение переменной `__name__`:

<!--
filename: chapter_14/import_name_check.py
-->

```python
from name_check import fib

print(fib(500))
```

<!--
runs: chapter_14/name_check.py
stdout: |
    144
-->

```bash
$ python3 name_check.py
144
```

<!--
runs: chapter_14/import_name_check.py
stdout: |
    610
-->

```bash
$ python3 import_name_check.py
610
```

## 3. Пакеты

Пакеты - это способ организации модулей в пространства имен, разделенные точкой. Пакет представляет собой директорию с служебным файлом `__init__.py` (который может быть и чаще всего пустой. Подробнее смотрите в офф. документации) и прочими модулями или другими пакетами.

Предположим, вы пишите приложение (или набор модулей – пакет) для обработки сигналов. Тогда, ваша файловая структура может выглядеть вот так:

```bash
signals                    # пакет signals
├── __init__.py            # 
├── core                   # пакет core – логика обработки сигналов
│   ├── __init__.py        # 
│   ├── filters.py         # модуль filters
│   ├── generators.py      # модуль generators
│   └── processors.py      # модуль processors
└── gui                    # пакет gui – графический интерфейс
    ├── __init__.py        # 
    ├── main.py            # модуль main
    └── widgets.py         # модуль widgets
```

В дальнейшим модули пакета `signals` можно импортировать так (как из вне пакета, так и в любом модуле внутри):

```python
import signals.core.filters
from signals.core import generators
```

Так же, модули внутри пакета могут быть импортированы относительно пакета. Например, в `signals/gui/main.py`:

```python
from . import widgets         # импорт модуля на текущем уровне вложенности
from .. import core           # импорт модуля на уровень выше
from ..core import processors # импорт модуля из пакета на уровень выше
```
