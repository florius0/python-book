# 11. Работа со строками

## 1. Строки

В Python строки являются неизменяемыми (иммутабельными) последовательностями символов в кодировке `utf-8`.

Литералы – `'текст строки'`, `'''текст строки'''`. Кавычки могут быть как одинарными (`'`), так и двойными (`"`). Кавычки, с которых строка начинается, должны совпадать с теми, которыми строка заканчивается. Таким образом `'текст строки"` – неверная запись. Строки с тремя кавычками (`'''`) могут занимать несколько строк в исходном коде программы. Строки с одинарными кавычками – только одну. Внутри строки можно использовать кавычки другого типа, если они не будут встречаться внутри строки. Например, `'текст "строки"'` – верная запись.

Так же перед литералом строки могут распологаться специальные символы – модификаторы литерала:

1. `r` – сырая строка (raw string). В этом случае специальные символы не будут интерпретироваться. Например, `r'\n'` – это строка из двух символов: обратный слэш и буква `n`. В обычной строке `\n` – это символ перевода строки.
2. `u` – строка в кодировке `utf-8`. По умолчанию строки являются строками в кодировке `utf-8`.
3. `b` – строка в кодировке `ascii`. По умолчанию строки являются строками в кодировке `utf-8`.
4. `f` – форматированная строка. Форматированная строка позволяет вставлять в неё переменные. Например, `f'Hello, {name}!'` – форматированная строка, в которую подставляется значение переменной `name`.

Конструкторы:

1. `str()` – возвращает пустую строку – `''`
2. `str(object)` – возвращает объект, преобразованный к строке.

Пример создания строк:

<!--
filename: chapter_11/string_creation.py
-->

```python
print('строка')                  # строка
print("строка")                  # строка
print('''строка''')              # строка
print(str('строка'))             # строка
print('''строка
с переносом''')                  # строка
                                 # с переносом
print('строка с "кавычками"')    # строка с "кавычками"
print("строка с 'кавычками'")    # строка с 'кавычками'

print(r'\n')                     # \n
print(u'строка')                 # строка
print(b'строка')                 # b'\xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0'
print(f'Hello, {'Py' * 3}thon!') # Hello, PyPyPython!

print(str(1))                    # 1
print(str(1.0))                  # 1.0
print(str(True))                 # True
print(str([1, 2, 3]))            # [1, 2, 3]
print(str((1, 2, 3)))            # (1, 2, 3)
print(str({1, 2, 3}))            # {1, 2, 3}
print(str({1: 1, 2: 2, 3: 3}))   # {1: 1, 2: 2, 3: 3}
print(str(None))                 # None
```

<!--
runs: chapter_11/string_creation.py
stdout: >
    строка
    строка
    строка
    строка
    строка
    с переносом
    1
    1.0
    True
    [1, 2, 3]
    (1, 2, 3)
    {1, 2, 3}
    {1: 1, 2: 2, 3: 3}
    None
-->

## 2. Специальные (escape) символы

В строках можно использовать специальные символы:

1. `\n` – перевод строки
2. `\t` – табуляция
3. `\v` – вертикальная табуляция
4. `\r` – возврат каретки
5. `\\` – обратный слэш
6. `\'` – одинарная кавычка
7. `\"` – двойная кавычка
8. `\xhh` – unicode-символ с кодом `hh` в шестнадцатеричной системе счисления
9. `\uxxxx` – unicode-символ с кодом `xxxx` в шестнадцатеричной системе счисления
10. `\Uxxxxxxxx` – unicode-символ с кодом `xxxxxxxx` в шестнадцатеричной системе счисления
11. `\N{name}` – символ с именем `name` в базе данных символов Unicode

Примечания:

1. Специальные символы одинарной и двойной кавычки необходимо использовать, если кавычки строкового литерала является одинарными или двойными соответственно.
2. Специальные символы 9-12 используются для вставки символов Unicode (по коду или по имени). Например, если вам необходимо вставить неразрывный пробел, то лучше использовать `\xa0` или `\N{NO-BREAK SPACE}`, так как неразрывный пробел визуально не отличим от обычного пробела, но в коде они различаются.

Существуют и другие специальные символы, но они используются очень редко. Чаще всего используются символы 1, 2, 5-7.

## 3. Методы класса `str`

По скольку строки являются неизменяемыми, то все методы, которые изменяют строку, возвращают новую строку, а не изменяют исходную.

### 1. Методы для работы с регистром

1. `str.lower()` – возвращает копию строки, в которой все символы в нижнем регистре.
2. `str.upper()` – возвращает копию строки, в которой все символы в верхнем регистре.
3. `str.capitalize()` – возвращает копию строки, в которой первый символ в верхнем регистре, а все остальные – в нижнем.
4. `str.title()` – возвращает копию строки, в которой первый символ каждого слова в верхнем регистре, а все остальные – в нижнем.

Пример:

<!--
filename: chapter_10/str_register_methods.py
-->

```python
s = 'Hello, world!'

print(s.lower()) # hello, world!
print(s.upper()) # HELLO, WORLD!
print(s.capitalize()) # Hello, world!
print(s.title()) # Hello, World!
```

<!--
runs: chapter_10/str_register_methods.py
stdout: >
    hello, world!
    HELLO, WORLD!
    Hello, world!
    Hello, World!
-->

### 2. Методы для работы с пробелами

1. `str.strip()` – возвращает копию строки, в которой удалены все пробелы в начале и в конце строки.
2. `str.lstrip()` – возвращает копию строки, в которой удалены все пробелы в начале строки.
3. `str.rstrip()` – возвращает копию строки, в которой удалены все пробелы в конце строки.

Пример:

<!--
filename: chapter_10/str_strip_methods.py
-->

```python
s = ' \tHello, world! \n'

print(s.strip())  # 'Hello, world!'
print(s.lstrip()) # 'Hello, world! \n'
print(s.rstrip()) # ' \tHello, world!'
```

<!--
runs: chapter_10/str_strip_methods.py
stdout: >
    Hello, world!
    Hello, world!

        Hello, world!
-->

### 3. Методы для проверки содержимого строки

1. `str.startswith(prefix[, start[, end]])` – возвращает `True`, если строка начинается с префикса `prefix`, иначе возвращает `False`.
2. `str.endswith(suffix[, start[, end]])` – возвращает `True`, если строка заканчивается суффиксом `suffix`, иначе возвращает `False`.
3. `str.isalpha()` – возвращает `True`, если строка состоит только из букв, иначе возвращает `False`.
4. `str.islower()` – возвращает `True`, если строка состоит только из строчных букв, иначе возвращает `False`.
5. `str.isupper()` – возвращает `True`, если строка состоит только из прописных букв, иначе возвращает `False`.
6. `str.isspace()` – возвращает `True`, если строка состоит только из пробельных символов, иначе возвращает `False`.
7. `str.istitle()` – возвращает `True`, если строка состоит только из слов, начинающихся с заглавной буквы, иначе возвращает `False`.
8. `str.isdigit()` – возвращает `True`, если строка состоит только из цифр, иначе возвращает `False`.
9. `str.isidentifier()` – возвращает `True`, если строка может быть использована в качестве идентификатора, иначе возвращает `False`.

Примечание: методы 1-2 принимает опциональные параметры start и end – индексы, которыми ограничен поиск (идентично `str[start:end].method(substring)`)

Пример:

<!--
filename: chapter_10/str_check_methods.py
-->

```python
s = 'Hello, world!'
print(s.startswith('Hello'))      # True
print(s.startswith('hello'))      # False

print(s.endswith('world!'))       # True
print(s.endswith('World!'))       # False

print(s.isalpha())                # False
print('Hello'.isalpha())          # True

print('hello'.islower())          # True
print('Hello'.islower())          # False

print('HELLO'.isupper())          # True
print('Hello'.isupper())          # False

print(' \t \n'.isspace())         # True
print(' \t \nHello'.isspace())    # False

print('Hello, World!'.istitle())  # True
print('Hello, world!'.istitle())  # False

print('123'.isdigit())            # True
print('123abc'.isdigit())         # False

print('hello'.isidentifier())     # True
print('hello world'.isidentifier()) # False
```

<!--
runs: chapter_10/str_check_methods.py
stdout: >
    True
    False
    True
    False
    False
    True
    True
    False
    True
    False
    True
    False
    True
    False
    True
    False
-->

### 4. Методы для работы с подстроками

Примечание: подстрокой называют часть строки.

1. `str.find(substring[, start[, end]])` – возвращает индекс первого вхождения подстроки в строку. Если подстрока не найдена, то возвращается `-1`. .
2. `str.rfind(substring[, start[, end]])` – возвращает индекс последнего вхождения подстроки в строку. Если подстрока не найдена, то возвращается `-1`.
3. `str.index(substring[, start[, end]])` – возвращает индекс первого вхождения подстроки в строку. Если подстрока не найдена, то вызывается исключение `ValueError`.
4. `str.rindex(substring[, start[, end]])` – возвращает индекс последнего вхождения подстроки в строку. Если подстрока не найдена, то вызывается исключение `ValueError`.
5. `str.count(substring[, start[, end]])` – возвращает количество вхождений подстроки в строку.
6. `str.replace(old, new)` – возвращает копию строки, в которой все вхождения подстроки `old` заменены на подстроку `new`.
7. `str.partition(substring)` – возвращает кортеж из трех элементов: подстроки до первого вхождения подстроки `substring`, самой подстроки `substring` и подстроки после первого вхождения подстроки `substring`.
8. `str.rpartition(substring)` – возвращает кортеж из трех элементов: подстроки до последнего вхождения подстроки `substring`, самой подстроки `substring` и подстроки после последнего вхождения подстроки `substring`.
9. `str.split(separator)` – возвращает список строк, полученных разбиением исходной строки по разделителю `separator`. Если разделитель не указан, то по умолчанию используется пробел.
10. `str.join(iterable)` – возвращает строку, полученную объединением строк из итерируемого объекта `iterable` с разделителем, равным строке, для которой вызывается метод.

Примечание: методы 1-5 принимает опциональные параметры start и end – индексы, которыми ограничен поиск (идентично `str[start:end].method(substring)`)

Пример:

<!--
filename: chapter_10/str_substr_methods.py
-->

```python
s = 'Hello, world!'

print(s.find('l'))  # 7
print(s.find('l', 8))  # 9
print(s.find('l', 8, 10))  # 9
print(s.find('l', 8, 9))  # -1

print(s.rfind('l'))  # 9

# index и rindex работают аналогично find и rfind, но в случае отсутствия подстроки вызывают исключение ValueError

print(s.count('l'))  # 3# 2

print(s.replace('l', 'L'))  # HeLLo, worLd!

print(s.partition('l'))  # ('He', 'l', 'lo, world!')

print(s.rpartition('l'))  # ('Hello, wor', 'l', 'd!')

print(s.split('l'))  # ['He', '', 'o, wor', 'd!']

print(' '.join(['Hello', 'world!']))  # Hello world!
```

<!--
runs: chapter_10/str_substr_methods.py
stdout: >
    7
    9
    9
    -1
    9
    3
    HeLLo, worLd!
    ('He', 'l', 'lo, world!')
    ('Hello, wor', 'l', 'd!')
    ['He', '', 'o, wor', 'd!']
    Hello world!
-->

## 4. Форматирование строк

Форматированием строк называют процесс подстановки в строку значений переменных, выражений и т.д. с целью получения результата в виде строки. В Python для форматирования строк используется метод `str.format()`. Он позволяет подставлять в строку значения переменных, выражений и т.д. в произвольном порядке и количестве. При этом в строке, которую необходимо отформатировать, вместо значений переменных, выражений и т.д. указываются специальные маркеры (placeholder'ы), которые заменяются на значения переменных, выражений и т.д. при вызове метода `str.format()`.

Помимо `str.format()` в Python есть еще два способа форматирования строк: оператор `%` и модификатор `f` (f-строки). `%` – это оператор форматирования строк, а `f-strings` – это специальный синтаксис, который позволяет форматировать строки с помощью выражений, заключенных в фигурные скобки.

Форматирование при помощи `%` мы не будем рассматривать, так как оно считается устаревшим.

### 1. Форматирование при помощи `str.format()`

Метод `str.format()` принимает произвольные позиционные и именованные аргументы и заменяет маркеры (placeholder'ы) на соответствующие значения. Маркеры имеют следующий вид:

```python
{[<identifier>][:<format>]}
```

где `[<identifier>]` – это опциональная часть синтаксиса, которая указывает, какой аргумент будет подставлен, а `[:<format>]` – это опциональная часть синтаксиса, которая указывает, каким образом будет произведена подстановка значения аргумента.

Обратите внимание на то, что перед опциями форматирования (`<format>`) должно стоять двоеточие (`:`).

#### Варианты идентификаторов

1. Отсутствующий идентификатор (тогда маркер будет выглядеть вот так: `{[:<format>]}`) – в этом случае аргументы будут подставляться в порядке их следования в списке аргументов метода `str.format()`. Например, если в метод `str.format()` передать два аргумента, то первый аргумент будет подставлен вместо первого маркера, а второй аргумент будет подставлен вместо второго маркера.
2. Идентификатор-число – указывает индекс позиционного аргумента, который будет подставлен вместо маркера. Например, если в метод `str.format()` передать два аргумента, то первый аргумент будет подставлен вместо маркера с идентификатором `0`, а второй аргумент будет подставлен вместо маркера с идентификатором `1`.
3. Идентификатор–имя – указывает имя именованного аргумента, который будет подставлен вместо маркера. Например, если в метод `str.format()` передать два аргумента, то первый аргумент будет подставлен вместо маркера с именем `first`, а второй аргумент будет подставлен вместо маркера с именем `second`.

Так же, можно получить поле подставляемого объекта, указав его через точку после идентификатора или элемент по индексу, указав его в квадратных скобках после идентификатора.

Пример:

<!--
filename: chapter_10/str_format_placeholder_identifier.py
-->

```python
class Person:
    pass

person = Person()
person.name = 'John'
person.surname = 'Doe'

print('{} {} {}'.format('a', 'b', 'c')) # a b c
print('{2} {1} {0}'.format('a', 'b', 'c')) # c b a
print('Hello, {name} {surname}!'.format(name='John', surname='Doe')) # Hello, John Doe!

print('Hello, {0.name[1]} {0.surname}!'.format(person)) # Hello, o Doe!
```

<!--
runs: chapter_10/str_format_placeholder_identifier.py
stdout: >
    a b c
    c b a
    Hello, John Doe!
    Hello, o Doe!
-->

#### Спецификаторы форматирования

Спецификатор форматирования имеет следующий вид: `[Выравнивание][Группировка][Тип]`

##### Типы

1. `s` – строка (по умолчанию).
2. `f` – число с плавающей точкой.
3. `F` – число с плавающей точкой (`inf`, `nan` в верхнем регистре).
4. `e` – число с плавающей точкой в экспоненциальном представлении.
5. `E` – число с плавающей точкой в экспоненциальном представлении (`inf`, `nan`, `e` в верхнем регистре).
6. `%` – процент.
7. `d` – целое число.
8. `b` – двоичное представление целого числа.
9. `o` – восьмеричное представление целого числа.
10. `x` – шестнадцатеричное представление целого числа.
11. `X` – шестнадцатеричное представление целого числа в верхнем регистре.
12. `c` – счиать число номером Unicode-символа.
13. `r` – строка с экранированием специальных символов.

Пример:

<!--
filename: chapter_10/str_format_placeholder_type.py
-->

```python
print('{:s}'.format('Hello')) # Hello
print('{:f}'.format(3.14)) # 3.140000
print('{:F}'.format(3.14)) # 3.140000
print('{:e}'.format(3.14)) # 3.140000e+00
print('{:E}'.format(3.14)) # 3.140000E+00
print('{:%}'.format(3.14)) # 314.000000%
print('{:d}'.format(65))   # 65
print('{:b}'.format(65))   # 1000001
print('{:o}'.format(65))   # 101
print('{:x}'.format(65))   # 41
print('{:X}'.format(65))   # 41
print('{:c}'.format(65))   # A
print('{:r}'.format('Hello')) # 'Hello'
```

<!--
runs: chapter_10/str_format_placeholder_type.py
stdout: >
    Hello
    3.140000
    3.140000
    3.140000e+00
    3.140000E+00
    314.000000%
    65
    1000001
    101
    41
    41
    A
    'Hello'
-->

При использовании опции `c` идентификатор должен быть целым числом. Если идентификатор не целое число, то будет сгенерировано исключение `ValueError`. Если идентификатор не указан, то будет сгенерировано исключение `IndexError`.

Так же, перед типами представления для чисел с плавающей точкой (float) можно указать точность представления числа. Для этого используется символ `.` и целое положительное число: `{:.2f}` отформатирует число `5.556` как `5.56`. Если точность не указана, то используется стандартная точность для представления числа.

##### Группировка (разделитель групп разрядов в числе)

1. `,` – использовать символ `','` для отделения разрядов в числах с плавающей точкой и десятичных представлениях целых чисел.
2. `_` – использовать символ `'_'` для отделения разрядов в числах с плавающей точкой и десятичных представлениях целых чисел. Для не-десятичных представлений целых чисел будет отделена каждая 4ая цифра.

Пример:

<!--
filename: chapter_10/str_format_placeholder_grouping.py
-->

```python
print('{:,}'.format(1000000)) # 1,000,000
print('{:_}'.format(1000000)) # 1_000_000
print('{:_x}'.format(1000000)) # f_4240
```

<!--
runs: chapter_10/str_format_placeholder_grouping.py
stdout: >
    1,000,000
    1_000_000
    f_4240
-->

##### Выравнивание

Тип выравнивания задается при помощи следующих символов:

1. `<` – выравнивание по левому краю.
2. `>` – выравнивание по правому краю.
3. `^` – выравнивание по центру.
4. `=` – выравнивание по правому краю так, что символам-заполнителям предшествует знак числа.

Опционально, перед символом выравнивания можно указать любой символ-заполнитель. Если символ-заполнитель не указан, то используется пробел.
После символа выравнивания можно указать ширину поля. Если ширина поля не указана, то используется минимальная ширина, достаточная для представления значения.

Пример:

<!--
filename: chapter_10/str_format_placeholder_alignment.py
-->

```python
print('{:<10}'.format('Hello')) # Hello     
print('{:>10}'.format('Hello')) #      Hello
print('{:^10}'.format('Hello')) #   Hello   
print('{:=10}'.format(100))     #       100
print('{:*>10}'.format('Hello')) # *****Hello
print('{:*<10}'.format('Hello')) # Hello*****
print('{:*^10}'.format('Hello')) # ***Hello***
```

<!--
runs: chapter_10/str_format_placeholder_alignment.py
stdout: >
    Hello     
         Hello
    Hello   
       100
    *****Hello
    Hello*****
    ***Hello***
-->

##### Знак числа

Опция знака числа указывается перед шириной поля. Она может принимать одно из следующих значений:

1. `-` – показывать знак числа только для отрицательных чисел – по умолчанию.
2. `+` – всегда показывать знак числа.
3. пробел – показывать знак числа только для отрицательных чисел, а для положительных чисел оставлять пробел.

Пример:

<!--
filename: chapter_10/str_format_placeholder_sign.py
-->

```python
print('{:-}'.format(100))     # 100
print('{:-}'.format(-100))    # -100
print('{:+}'.format(100))     # +100
print('{: }'.format(100))     #  100

print('{:0=10+}'.format(100)) # +0000000100
```

Пример использования всех опций:

<!--
filename: chapter_10/str_format_placeholder_all.py
-->

```python
print('{:=^+20_.2f}'.format(1234.567)) # =====+1_234.57======
```

<!--
runs: chapter_10/str_format_placeholder_all.py
stdout: >
    =====+1_234.57======
-->

### 2. Модификатор `f` (f-строки)

Модификатор `f` позволяет вставлять в строку выражения, значение которых будет вычислено и подставлено в строку. Выражение должно быть окружено фигурными скобками (`{}`). Для того, чтобы вставить в строку символ фигурной скобку, нужно повторить ее дважды без пробела: `{{` и `}}`.

Помимо этого:

- через двоеточие можно указать форматирование значения выражения, точно так же, как и при использовании метода `format()`
- после выражения можно добавить знак `=`, и тогда выражение будет выведено вместе с его значением.

Пример:

<!--
filename: chapter_10/str_fstring.py
-->

```python
name = 'John'

print(f'Hello, {name}!') # Hello, John!

print(f'{{}}') # {}

print(f'{name.upper():*>10}') # *****JOHN
print(f'{name.upper()=}') # name.upper()=JOHN
```

<!--
runs: chapter_10/str_fstring.py
stdout: >
    Hello, John!
    {}
    *****JOHN
    name.upper()=JOHN
-->