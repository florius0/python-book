# 12. Работа с множествами (`set` и `frozenset`)

Множества в Python – это неупорядоченные коллекции уникальных объектов. Так как коллекция неупорядоченная, то мы не можем обращаться к элементам множества по индексу.
Объект может быть элементом множества, если он является хэшируемым. Это значит, что объект должен иметь метод `__hash__`, который возвращает хэш-значение объекта. Если объект не является хэшируемым, то он не может быть элементом множества. Например, списки не являются хэшируемыми, поэтому списки не могут быть элементами множества.

Примечание: хэш – это число, которое вычисляется для объекта. Хэш-значение объекта неизменно, если объект неизменяемый. Хэш-значение объекта может измениться, если объект изменяемый.

## 1. `frozenset`

Иммутабельное множество.

Не имеет литерала.

Конструкторы:

1. `frozenset()` – создает пустое множество
2. `frozenset(iterable)` – создает множество из элементов `iterable`. Каждый элемент должен быть хэшируемым.

Для `frozenset` определены следующие операции:

| Операция                          | Результат                                                                                |
| --------------------------------- | ---------------------------------------------------------------------------------------- |
| `set.isdisjoint(other)`           | `True` если у `set` и `other` нет общих элементов , иначе `False`                        |
| `set.issubset(other)`             | `True` если все элементы `set` есть в `other` , иначе `False`                            |
| `set <= other`                    | Аналогично `set.issubset(other)`                                                         |
| `set < other`                     | `True` если все элементы `set` есть в `other` и `set` не равно `other` , иначе `False`   |
| `set.issuperset(other)`           | `True` если все элементы `other` есть в `set`, иначе `False`                             |
| `set >= other`                    | Аналогично `set.issuperset(other)`                                                       |
| `set > other`                     | `True` если все элементы `other` есть в `set` и `set` не равно `other`, иначе `False`    |
| `set.union(other, ...)`           | Новое множество с элементами `set` и `other`                                             |
| `set | other | ...`               | Аналогично `set.union(other, ...)`                                                       |
| `set.intersection(other, ...)`    | Новое множество с элементами которые есть в `set` и в `other`                            |
| `set & other & ...`               | Аналогично `set.intersection(other, ...)`                                                |
| `set.difference(other, ...)`      | Новое множество с элементами `set`, которых нет в `other`                                |
| `set - other - ...`               | Аналогично  `set.difference(other, ...)`                                                 |
| `set.symmetric_difference(other)` | Новое множество с элементами, которые есть только в `set` и `other`, но не в обоих сразу |
| `set ^ other`                     | Аналогично  `set.symmetric_difference(other)`                                            |
| `set.copy()`                      | Копия множества (копируется только множество, но не его элементы)                       |

Для некоторых методов определены соответствующие операторы. Аргументами операторов могут только множества, а методов – любые итерируемые объекты.

По скольку множества являются итерируемыми то все операции для итерируемых объектов, перечисленные в 9ой главе, работают и для множеств

Пример:

<!--
filename: chapter_11/frozenset.py
-->

```python
a = frozenset([1, 2, 3])
b = frozenset([2, 3, 4])

print(a.isdisjoint(b))  # False
print(a.issubset(b))  # False
print(a.issuperset(b))  # False
print(a.union(b))  # frozenset({1, 2, 3, 4})
print(a.intersection(b))  # frozenset({2, 3})
print(a.difference(b))  # frozenset({1})
print(a.symmetric_difference(b))  # frozenset({1, 4})
```

<!--
runs: chapter_11/frozenset.py
stdout: >
    False
    False
    False
    frozenset({1, 2, 3, 4})
    frozenset({2, 3})
    frozenset({1})
    frozenset({1, 4})
-->

## 2. `set`

Мутабельное множество

Литерал – `{element1, element2, ...}`. Пустое множество – `set()` (так как `{}` – пустой словарь, подробнее об этом в следующей главе).

Конструкторы:

1. `set()` – создает пустое множество
2. `set(iterable)` – создает множество из элементов `iterable`. Каждый элемент должен быть хэшируемым.

Для `set` определены все те же операции, что и для `frozenset` и дополнительно определены следующие операции:

| Операция                                      | Результат                                                                                                     |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `set.update(other, ...)`                      | Обновляет множество, добавляя все элементы из `other`                                                         |
| `set |= other | ...`                          | Аналогично `update(other, ...)`                                                                               |
| `set.intersection_update(other, ...)`         | Обновляет множество, сохраняя только те элементы, которые встречаются в `other`                               |
| `set &= other & ...`                          | Аналогично `intersection_update(other, ...)`                                                                  |
| `set.difference_update(other, ...)`           | Обновляет множество, сохраняя только те элементы, которые не встречаются в `other`                            |
| `set -= other | ...`                          | Аналогично `difference_update(other, ...)`                                                                    |
| `set.symmetric_difference_update(other, ...)` | Обновляет множество, сохраняя только те элементы, которые есть только в `set` и `other`, но не в обоих сразу |
| `set ^= other`                                | Аналогично `symmetric_difference_update(other, ...)`                                                          |
| `set.add(elem)`                               | Добавляет элемент в множество                                                                                 |
| `set.remove(elem)`                            | Удаляет элемент из множества. Если элемента в множестве нет – вызывает `KeyError`                            |
| `set.discard(elem)`                           | Удаляет элемент из множества.                                                                                 |
| `set.pop()`                                   | Возвращает произвольный элемент множества и удаляет его из множества                                          |
| `set.clear()`                                 | Удаляет все элементы множества                                                                                |

Пример:

<!--
filename: chapter_11/set.py
-->

```python
a = {1, 2, 3}
b = {2, 3, 4}

a.update(b)
print(a)  # {1, 2, 3, 4}

a.intersection_update(b)
print(a)  # {2, 3, 4}

a.difference_update(b)
print(a)  # {1}

a = {1, 2, 3}

a.symmetric_difference_update(b)
print(a) # {1, 4}

a.add(5)
print(a) # {1, 4, 5}

a.remove(5)
a.discard(4)
print(a) # {1}

print(a.pop()) # 1
print(a) # set()

a = {1, 2, 3}
a.clear()
print(a) # set()
```

<!--
runs: chapter_11/set.py
stdout: >
    {1, 2, 3, 4}
    {2, 3, 4}
    {1}
    {1, 4}
    {1, 4, 5}
    {1}
    1
    set()
    set()
-->