# 5. Переменные и типы данных

В прошлой главе мы работали со строками, но в `Python` так же существют и другие типы данных, работу с которыми мы рассмотрим в этой главе.

Так же в прошлой главе мы упоминали литералы. Литерал – это способ записи (нотация) для обозначния фиксированного значения в исходном коде программы.

## 1. `NoneType`

У этого типа есть только одно значение – `None`, которое является литералом. У данного типа нет конструктора. Обозначает отсутствие данных

## 2. `bool`

У этого типа данных есть только 2 значения-литерала: `True` и `False`.

Так же существует конструктор – `bool(value)'`, который преобразует данные любого типа к `bool`. Определен так, что

1. `bool() = False`
2. `bool(None) = False`
3. `bool(a) = False`, где `a` – 0 любого численного типа.
4. `bool(s) = False`, где `s` – любой пустой итерируемый объект.
5. `bool(value) = True` во всех остальных случаях

Так же для этого типа (и тех типов, которые могут быть приведины к `bool`) определены следующие операции

| Операция  | Название       | Результат                                  |
| --------- | -------------- | ------------------------------------------ |
| `x or y`  | Логическое или | Если `x` равно `True` то `y` иначе `x`     |
| `x and y` | Логическое и   | Если `x` равно `False` то `x` иначе `y`    |
| `not x`   | Логическое не  | Если `x` равно `False` то `True` иначе `y` |

## 3. Численные типы

Эти типы данных преднозначены для представления различных чисел. Для каждого из них определены следующие операции.

| Операция | Название              | Примечания                                  |
| -------- | --------------------- | ------------------------------------------- |
| `x + y`  | Сложение              |                                             |
| `x - y`  | Вычитание             |                                             |
| `x * y`  | Умножение             |                                             |
| `x / y`  | Деление               |                                             |
| `x % y`  | Остаток от деления    | `x % y = x - n * y`, где `n = x // y`       |
| `x // y` | Целочисленное деление | Округленное к минус бесконечноти `x / y`    |
| `x ** y` | Возведение в степень  | В Python как и в других языках `0 ** 0 = 1` |
| `-x`     | Отрицание             | Меняет знак числа на противоположный        |
| `+x`     |                       | Не изменяет знак числа                      |

### 1. `int`

Значения этого типа – произвольные целые числа (любой длинны, в отличии от некоторых других языков). Литералы могут содержать цифры `0`-`9`, символы `a` - `f` и `A` - `F` (могут быть использованы только если число задано в шестнадцетиричной системе исчесления), знак `-` (самым первым символом), префиксы `0b`, `0o`, `0x`, обозначающие, что число будет записано в двоичной, восьмеричной и шестнадйатиричной системе исчисления соответствеено.

Конструкторы:

1. `int()` – возвращает `0`
2. `int(s, base)`, где s – строка, base – опциональный параметр типа `int`, по умолчанию равен `10`. Преобразует строковое представление целого числа `s` в системе исчесления с основанием `base` в число типа `int`
3. `int(f)` – где f – число типа float.

Примеры целых чисел, заданых литералами:

| Литерал             | Значение (в десятичной системе исчесления) | Примечания                                                                |
| ------------------- | ------------------------------------------ | ------------------------------------------------------------------------- |
| `1234567890`        | `1234567890`                               |                                                                           |
| `-1234567890`       | `-1234567890`                              |                                                                           |
| `001`               | `1`                                        | Незначащие цифры опускаются                                               |
| `0b101`             | `5`                                        | Число в двоичной системе исчесления                                       |
| `-0b101`            | `-5`                                       | Числа в не-дестичной системе исчесления тоже могу быть отрицательными     |
| `0b00101`           | `5`                                        | Незначащие цифры опускаются и для числа в не-дестичной системе исчесления |
| `0o1234567`         | `342391`                                   | Число в восьмеричной системе исчесления                                   |
| `0x123456789abcdef` | `81985529216486895`                        | Число в шестнадтцетиричной системе исчесления                             |
| `0x123456789ABCDEF` | `81985529216486895`                        | Цифры `A-F` могут быть обозначены как большими, так и маленькими буквами  |

Так же только для чисел типа `int` определены следующие побитовые операци:

| Операция | Результат                                 |
| -------- | ----------------------------------------- |
| `x \| y` | Побитовое или `x` и `y`                   |
| `x ^ y`  | Исключающее побитовое или (xor) `x` и `y` |
| `x & y`  | Побитовое и `x` и `y`                     |
| `x << n` | Побитовой сдвиг `x` на `n` влево          |
| `x >> y` | Побитовой сдвиг `x` на `n` вправо         |

### 2. `float`

Значени этого типа – числа с плавающей точкой. Точность ограничена 64 битами. Числа типа float реализованы в соответствии с [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754).
float-литералы могут содержать цифры `0`-`9`, десятичный разделитель `.`, знак `-` (самым первым символом), суффикс вида `e<x>` или `E<x>` ([scientifc notation](https://en.wikipedia.org/wiki/Scientific_notation)), где `<x>` – целочисленный литерал. Этот суффиккс означает, что число умножено на 10 в степени `x`.

Конструкторы:

1. `float()` – возвращает `0.0`
2. `float(i)`, где `i` – число типа `int`. Преобразует число типа `int` в число типа `float`
3. `float(s)`, где `s` – строка. Преобразует строковое представление числа в число типа `float`

Примеры чисел с плавающей точкой, заданных литералами

| Литерал  | Значение | Примечания                                                                                |
| -------- | -------- | ----------------------------------------------------------------------------------------- |
| `1.0`    | `1.0`    |                                                                                           |
| `-1.0`   | `-1.0`   |                                                                                           |
| `0.1`    | `0.1`    |                                                                                           |
| `1.`     | `1.0`    | Незначащий 0 после точки можно опкускать                                                  |
| `.1`     | `0.1`    | Незначащий 0 до точки можно опускать                                                      |
| `1.23e2` | `123.0`  | Эквивалентно `1.23 * 10 ** 2`                                                             |
| `123e-2` | `1.23`   | Эквивалентно `123 * 10 ** -2`. Если используется `e<x>`, то `.` в литерале можно опускать |

### 3. `complex`

Тип для представления комплексных чисел. Литерал – `<re>+<im>j` или `<re>-<im>j` в заввисимости от знака перед мнимой частью. `<re>` и `<im>` – float-литералы, вещественная и мнимая части соответственно.

Конструкторы:

1. `complex()` – возвращает `0+0j`
2. `complex(re)`, где `re` – число типа float или int. Возвращает `re + 0j`
3. `complex(re, im)`, где `re` и `im` – числа типа float или int. Возвращает `re + im * 1j`

Примеры комплексных чисел, заданных литералами

| Литерал    | Значение      | Примечания                     |
| ---------- | ------------- | ------------------------------ |
| `1+2j`     | `(1+2j)`      |                                |
| `1-2j`     | `(1-2j)`      |                                |
| `1.0+2.0j` | `(1+2j)`      | `.` можно опускать             |
| `1e5+0j`   | `(100000+2j)` | Допустимы любые float-литералы |
| `.1+.1j`   | `(.1+.1j)`    | Допустимы любые float-литералы |

## 4. Итерируемые типы

Для всех итерируемых типов существуют операции:

| Операция     | Результат                                | Примечания |
| ------------ | ---------------------------------------- | ---------- |
| `x in s`     | `True`, если s содержит x, иначе `False` | 1          |
| `x not in s` | `False`, если s содержит x, иначе `True` | 1          |
| `len(s)`     | Длинна `s`                               |            |
| `min(s)`     | Наименьший элемент `s`                   | 2          |
| `max(s)`     | Наибольший элемент `s`                   | 2          |

Примечания:

1. Для большинства последовательностей `in` и `not in` используются для проверки того, содержит ли последовательность определенный элемент, однако для типов `str` и `bytes` эти операции проверют, содержит ли последовательность некоторую подпоследовательность.
2. `min` и `max` вызывают исключение `ValueError` если последовательность `s` пустая.

### 1. Типы-последовательности

Для всех типов-последовательностей определены следующие операции

| Операция            | Результат                                                                                                                        | Примечания |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| `s + t`             | Конкатенация `s и t`                                                                                                             | 5, 6       |
| `s * n` или `n * s` | Конкатенация `n` последовательнотей `s`                                                                                          | 1, 6       |
| `s[i]`              | `i`-тый элемент `s`                                                                                                              | 2          |
| `s[i:j]`            | Подпоследовательность с `i`-го (включительно) по `j`-ый (невключительно) элемент `s`                                             | 2, 3       |
| `s[i:j:k]`          | Подпоследовательность с `i`-го (включительно) по `j`-ый (невключительно) элемент `s` с шагом `k`                                 | 2, 4       |
| `s.index(x, i, j)`  | Самый первый индекс `x` в `s` начиная с `i` (включительно) и заканчивая `j` (невключительно). `i` и `j` – опциональные параметры | 7          |
| `s.count(x)`        | Количество `x` в `s`                                                                                                             |            |

Где `s`, `t` – последовательности; `n, i, j, k` – целыые числа (типа `int`)

Примечания:

1. Значения `n`, которые меньше 0 считаются равным 0 (что приводит к получению пустой последдовательности). Учтите, что элементы последовательности `s` не копируются. Полученная последовательность содержит ссылки на эти элементы.
2. `i` и `j` меньше 0 эквивалентны `len(s) - i` и `len(s) - j` соответственно. (`-0` все равно считается равным `0`). Индексация начинается с 0.
3. Эта операция называется _срез_ или _slice_. Если `i` или `j` больше `len(s)` то они уменьшаются ддо `len(s)`. Если `i` опущена (`s[i:]`) или равна `None`, то `i` трактуется как `0`. Если `о` опущена (`s[:j]`) или равна `None`, то `j` трактуется как `len(s)`. Если `i` больше или равно `j`, то slice пустой.
4. Slice от `i` до `j` с шагом `k` определен как последовательность элементов `s` с индедксами, равными `x = i + n * k`, где `0 <= n < (j - i) / k`. Если `k` положительно – `i` и `j` уменьшаются до `len(s)`, если превосходят `len(s)`. Если `k` отрицательно – `i` и `j` уменьшаются до `len(s) - 1`, если превосходят `len(s) - 1`. `k` не может быть равным `0`. Если `k` опущено или `None` то `k` трактуется как `1`.
5. Конкатенация иммутабельных последовательностей всегда создает новую последовательность.
6. Некоторые типы, например `range` поддерживают только последовательности, которые следуют определенным правилам, и поэтому не поддерживают конкатенацию или повторение.
7. `index` вызывает исключение `ValueError` если в последовательности нет элемента `x`.

#### Иммутабельные последовательности

Иммутабельные последовательности, в отличии от мутабельных, определяют `hash(s)` по умолчанию и в следствии этого могут быть использованы как ключи для словарей (`dict` и другие), значения для параметров по умолчанию в функциях и как элементы множеств (`set` и `frozenset`).

#### Мутабельные последовательности

Для мутабельных последовательностей дополнительно определены следующие операции

| Операция                | Результат                                                                                                                  | Примечания                                                   |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `s[i] = x`              | Заменят элемент с индексом `i` на `x`                                                                                      |                                                              |
| `s[i:j] = t`            | Заменяет slice с `i` по `j` элементами `t`                                                                                 |                                                              |
| `del s[i:j`]            | Эквивалетно `s[i:j] = []`                                                                                                  |                                                              |
| `s[i:j:k] = t`          | Заменяет элементы `s[i:j:k]` элементами `t`                                                                                | `t` должна иметь такую же длинну, как и slice                |
| `del s[i:j:k`]          | Удаляет элементы `s[i:j:k]` из последовательности                                                                          |                                                              |
| `s.append(x`)           | Добаляет x в конец последовательности                                                                                      |                                                              |
| `s.clear()`             | Удаляет все элементы из последовательности `s` (эквивалентно `del s[:]`)                                                   |                                                              |
| `s.copy()`              | Создает копию `s` (эквивалентно `s[:]`)                                                                                    | Копируется только сама последоательноссть, но не ее элементы |
| `s.extend(t) or s += t` | Дополняет `s` содержимым `t`                                                                                               |                                                              |
| `s *= n`                | Обновляет `s` так что содержимое повторяется `n` раз                                                                       |                                                              |
| `s.insert(i, x`)        | Вставляет `x` по индексу `i`                                                                                               |                                                              |
| `s.pop(i`)              | Получает элемент по индексу `i` и удаляет его из последовательности. `i` – опциональный параметр, равный `-1` по умолчанию |                                                              |
| `s.remove(x`)           | Удаляет первый элемент, равный `x` из `s`                                                                                  | Вызывает `ValueError` если `s` не содержит `x`               |
| `s.reverse()`           | "Переворачивает" `s` на месте (не создает новую последовательность)                                                        |                                                              |

#### 1. `tuple`

`tuple`, или кортеж – иммутабельная последовательность произвольных элементов. Иммутабельность кортежа распостраняется только на сам кортеж, а не на его значения (так как в Python все передается по ссылке):

<!--
filename: chapter_5/tuple_immutability.py
-->

```python
a = [1, 2, 3]
b = (a, )
print(b)
a.append(4)
print(b)
```

напечатает

<!--
runs: chapter_5/tuple_immutability.py
-->

```bash
([1, 2, 3],)
([1, 2, 3, 4],)
```

Литерал – `(element1, element2, ... elementN)`, где `element1`, `element2`, `elementN` – элементы кортежа. Пустой кортеж может быть задан как `()`. Кортеж с одним элементом – как `(a, )`. Скобки – опциональны, кроме тех случаев когда надо задать пустой кортеж, или необходимы для избежания двусмысленности, например: `f(a, b)` – вызов функции с двумя аргументами, `f((a, b))` – вызов функции с одним аргументом, который является кортежем.

Конструкторы:

1. `tuple()` – возращает пустой кортеж – `()`
2. `tuple(iterable)`, где `iterable` – итерируемый объект. Возвращает кортеж из элементов итерируемого объекта

#### 2. `list`

Список – изменяемая последовательность произвольных элементов

Литерал – `[element1, element2, ... elementN]`. Литерал пустого списка – `[]`

Конструкторы – аналогично котрежу:

1. `list()` – возращает пустой список – `[]`
2. `list(iterable)`, где `iterable` – итерируемый объект. Возвращает список из элементов итерируемого объекта

#### 3. `range`

Неизменяемая последовательность чисел.

Не имеет литерала.

Конструкторы:

1. `range(stop)` – вернет диапазон чисел с 0 до `stop` невключительно c шагом `1`
2. `range(start, stop, step)` – вернет диапазон чисел от `start` до `stop` невключительно с шагом `step`. Параметр `step` – опционален и по умолчанию равен 1

где `start`, `stop`, `step` – числа типа `int`

#### 4. `str`

Иммутабельная строка в кодировке `utf-8`.

Литералы – `'текст строки'`, `'''текст строки'''`. Кавычки могут быть как одинарными (`'`), так и двойными (`"`). Кавычки, с которых строка начинается, должны совпадать с теми, которыми строка заканчивается. Таким образом `'текст строки"` – неверная запись. Строки с тремя кавычками (`'''`) могут занимать несколько строк в исходном кодде программы. Строки с одинарными кавычками – только одну.

Конструкторы:

1. `str()` – возвращает пустую строку – `''`
2. `str(object)` – возвращает объект, преобразованный к строке.

Работа со строками будет подробно рассмотрена в одной из следующих глав.

#### 5. `bytes`

Байты или bitstring (битстринг, нет принятого перевода). Литералы такие же как и у обычных строк, но с префисом `b` (`b'bytes'`, `b'''bytes'''`). В литералах разрешены только ASCII-символы.

### 2. Типы-множества

Множества в Python – это неупорядоченные коллекции уникальных хешируемых объектов. Хеширумеый объект это такой объект, для которого определен метод `__hash__` (результат этого метода не должен менятся в течении жизненного цикла объекта) и метод сравнения – `__eq__`. Числа, объекты типа `bool`, иммутабельные коллекции – хешируем, и соответтвенно могут быть элементами множеств

#### 1. `frozenset`

Иммутабельное множество

Не имеет литерала.

Конструкторы:

1. `frozenset()` – создает пустое множество
2. `frozenset(iterable)` – создает множество из элементов `iterable`. Каждый элемент должен быть хешируемым.

Для `frozenset` определены следующие операции:

| Операция                          | Результат                                                                                |
| --------------------------------- | ---------------------------------------------------------------------------------------- |
| `set.isdisjoint(other)`           | `True` если у `set` и `other` нет общих элементов , иначи `False`                        |
| `set.issubset(other)`             | `True` если все элементы `set` есть в `other` , иначи `False`                            |
| `set <= other`                    | Аналогично `set.issubset(other)`                                                         |
| `set < other`                     | `True` если все элементы `set` есть в `other` и `set` не равно `other` , иначи `False`   |
| `set.issuperset(other)`           | `True` если все элементы `other` есть в `set`, иначи `False`                             |
| `set >= other`                    | Аналогично `set.issuperset(other)`                                                       |
| `set > other`                     | `True` если все элементы `other` есть в `set` и `set` не равно `other`, иначи `False`    |
| `set.union(other, ...)`           | Новое множество с элементами `set` и `other`                                             |
| `set | other | ...`               | Аналогично `set.union(other, ...)`                                                       |
| `set.intersection(other, ...)`    | Новое множество с элементами которые есть в `set` и в `other`                            |
| `set & other & ...`               | Аналогично `set.intersection(other, ...)`                                                |
| `set.difference(other, ...)`      | Новое множество с элементами `set`, которых нет в `other`                                |
| `set - other - ...`               | Аналогично  `set.difference(other, ...)`                                                 |
| `set.symmetric_difference(other)` | Новое множество с элементами, которые есть только в `set` и `other`, но не в обоих сразу |
| `set ^ other`                     | Аналогично  `set.symmetric_difference(other)`                                            |
| `set.copy()`                      | Копия множествва (копируется только множество, но не его элементы)                       |

Для некоторых методов определены соответствующие операторы. Аргументами операторов могут только множества, а методов – любые итериремуе объекты.

#### 2. `set`

Мутабельное множество

Не имеет литерала.

Конструкторы:

1. `set()` – создает пустое множество
2. `set(iterable)` – создает множество из элементов `iterable`. Каждый элемент должен быть хешируемым.

Для `set` определены все те же операции, что и для `frozenset` и дополнительно определены следующие операции:

| Операция                                      | Результат                                                                                                     |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `set.update(other, ...)`                      | Обновляет множество, добавляя все элементы из `other`                                                         |
| `set |= other | ...`                          | Аналогично `update(other, ...)`                                                                               |
| `set.intersection_update(other, ...)`         | Обновляет множество, сохраняя только те элементы, которые встречаются в `other`                               |
| `set &= other & ...`                          | Аналогично `intersection_update(other, ...)`                                                                  |
| `set.difference_update(other, ...)`           | Обновляет множество, сохраняя только те элементы, которые не встречаются в `other`                            |
| `set -= other | ...`                          | Аналогично `difference_update(other, ...)`                                                                    |
| `set.symmetric_difference_update(other, ...)` | Обновляет множество, сохрааняя только те элементы, которые есть только в `set` и `other`, но не в обоих сразу |
| `set ^= other`                                | Аналогично `symmetric_difference_update(other, ...)`                                                          |
| `set.add(elem)`                               | Добавляет элемент в множество                                                                                 |
| `set.remove(elem)`                            | Удаляет элемент из множества. Если элемента в множествве нет – вызывает `KeyError`                            |
| `set.discard(elem)`                           | Удаляет элемент из множества.                                                                                 |
| `set.pop()`                                   | Возвращает произвольный элемент множества и удаляет его из множества                                          |
| `set.clear()`                                 | Удаляет все элементы множества                                                                                |

### 3. Типы-отображения – `dict`

Мутабельный тип данных.

Представляет собой отображение хешируемых объектов в произвольные объекты.

Литерал – `{key1: value1, key2: value2, ... keyN: valueN}`. Литерал пустого словаря – `{}`.

Конструкторы:

1. `dict()` – создает пустой словарь
2. `dict(key1=value1, key2=value2, ... keyN=valueN)` – создает словарь вида `{'key1': value1, 'key2': value2, ... 'keyN': valueN}`
3. `dict(mapping, key1=value1 ...)` – создет новый словарь из существующего, добавляя или обновляя элементы словаря, переданые как опциональные именованные параметры (`key1=value1 ...`)
4. `dict(iterable, key1=value1 ...)` – создает новывй словарь из итерируемого объекта, содержащего итерируемые объекты – пары ключ-значение (например, [(key1, value1), (key2, value2), ... (keyN, valueN)]), добавляя или обновляя элементы словаря, переданые как опциональные именованные параметры

Словарь – тоже итерируемый объект, и итерация происходит по ключам. В этом можно убедится при помощи конструктора `list` следующим образом:

<!--
filename: chapter_5/dict_iteration.py
-->

```python
d = {'a': 1, 'b': 2}
print(list(d))
```

<!--
TODO: add to checker ability to run tests without fences block
runs: chapter_5/dict_iterator.py
stdout: >
    ['a', 'b']
-->

Результатом выполнения указанного выше кода будет `['a', 'b']`

Для `dict` определены следующие операции:

| Операция              | Результат                                                                                                                                                                                                          |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `d[key] = value`      | Добавляет или обновляет значение в словаре, соответсвующее ключу                                                                                                                                                   |
| `del d[key]`          | Удаляет пару ключ – значени из словаря. Если ключа в словаре нет – вызывает исключение `KeyError`                                                                                                                  |
| `key in d`            | `True` если в словаре есть ключ, иначе `False`                                                                                                                                                                     |
| `key not in d`        | Эквивалентно `not key in d`                                                                                                                                                                                        |
| `d.clear()`           | Удаляет все элементы из словаря                                                                                                                                                                                    |
| `d.copy()`            | Копирует словарь (только словарь, но не его элементы)                                                                                                                                                              |
| `d.get(key, default)` | Получает значени, соответствующее ключу или `default`, если ключа в словаре нет. `default` – опциональный параметр и равен по умолчанию `None`                                                                     |
| `d.items()`           | Возвращает итерируемый объект с парами ключ-значение                                                                                                                                                               |
| `d.keys()`            | Возвращает итерируемый объект с ключамми словаря                                                                                                                                                                   |
| `d.values()`          | Возвращает итерируемый объект со значениями словаря                                                                                                                                                                |
| `d.pop(key, default)` | Возвращает значение, соответствующее словарю и удаляет пару ключ-значние из словаря. Если ключа в словаре – опциональный параметр `default`. Если `default` не указан и ключа в словаре нет – вызывает `KeyErrror` |
| `d.popitem()`         | Возвращает пару ключ-значение и удаляет ее из словаря в порядке Last-In-First-Out                                                                                                                                  |
| `d.update(other)`     | Добавляет и обновляет пары ключ-значения парами из словаря other                                                                                                                                                   |

где `d`, `other` – словарь, `key` – ключ, `value` – значение

## Задания

Напишите программы:

1. Для решения квадратных и кубических уравнений (с комплексными корнями)
2. Которая печатает перевернутую введенную строку
3. Которая печатает каждый второй символ введенной строки
4. Которая печатает символы введенной строи со второго по предпоследний и длинны исходной и полученной строки
5. Которая проверяет, что введеная строка не содержит повторяющихся символов.
