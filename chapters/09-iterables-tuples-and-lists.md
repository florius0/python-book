# 9. Итерируемые типы данных. Кортежи и списки

Итерируемыми типами данных называют такие типы, для которых определена операция получения элемента (метод `__getitem__`, который python вызывает при использовании оператора индексации – квадратных скобок – `datatype[indexer]`) или операция получения итератора (метод `__iter__`, который python вызывает у объекта, переданного встроенной функции `iter` или в циклах или генераторах) – специального объекта, предназначенного для однократной итерации (прохода по элементам).

Для всех итерируемых типов существуют операции:

| Операция      | Результат                                                                                     | Примечания |
| ------------- | --------------------------------------------------------------------------------------------- | ---------- |
| `x in s`      | `True`, если s содержит x, иначе `False`                                                      | 1          |
| `x not in s`  | `False`, если s содержит x, иначе `True`                                                      | 1          |
| `len(s)`      | Длинна `s`                                                                                    |            |
| `min(s)`      | Наименьший элемент `s`                                                                        | 2          |
| `max(s)`      | Наибольший элемент `s`                                                                        | 2          |
| `all(s)`      | `True`, если все элементы `s` истинны, иначе `False`                                          | 3          |
| `any(s)`      | `True`, если хотя бы один элемент `s` истинен, иначе `False`                                  | 3          |
| `reversed(s)` | Обратный итератор по `s` (итератор, который возвращает элементы итератора в обратном порядке) | 4          |

Примечания:

1. Для большинства последовательностей `in` и `not in` используются для проверки того, содержит ли последовательность определенный элемент, однако для типов `str` и `bytes` эти операции проверяют, содержит ли последовательность некоторую подпоследовательность.
2. `min` и `max` вызывают исключение `ValueError` если последовательность `s` пустая.
3. `all` и `any` возвращают `True` для пустых последовательностей.

Для всех типов-последовательностей определены следующие операции

| Операция            | Результат                                                                                                                        | Примечания |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| `s + t`             | Конкатенация `s и t`                                                                                                             | 5, 6       |
| `s * n` или `n * s` | Конкатенация `n` последовательностей `s`                                                                                         | 1, 6       |
| `s[i]`              | `i`-тый элемент `s`                                                                                                              | 2          |
| `s[i:j]`            | Подпоследовательность с `i`-го (включительно) по `j`-ый (невключительно) элемент `s`                                             | 2, 3       |
| `s[i:j:k]`          | Подпоследовательность с `i`-го (включительно) по `j`-ый (невключительно) элемент `s` с шагом `k`                                 | 2, 4       |
| `s.index(x, i, j)`  | Самый первый индекс `x` в `s` начиная с `i` (включительно) и заканчивая `j` (невключительно). `i` и `j` – опциональные параметры | 7          |
| `s.count(x)`        | Количество `x` в `s`                                                                                                             |            |

Где `s`, `t` – последовательности; `n, i, j, k` – целые числа (типа `int`)

Примечания:

1. Значения `n`, которые меньше 0 считаются равным 0 (что приводит к получению пустой последовательности). Учтите, что элементы последовательности `s` не копируются. Полученная последовательность содержит ссылки на эти элементы.
2. `i` и `j` меньше 0 эквивалентны `len(s) - i` и `len(s) - j` соответственно. (`-0` все равно считается равным `0`). Индексация начинается с 0.
3. Эта операция называется _срез_ или _slice_. Если `i` или `j` больше `len(s)` то они уменьшаются ддо `len(s)`. Если `i` опущена (`s[i:]`) или равна `None`, то `i` трактуется как `0`. Если `о` опущена (`s[:j]`) или равна `None`, то `j` трактуется как `len(s)`. Если `i` больше или равно `j`, то slice пустой.
4. Slice от `i` до `j` с шагом `k` определен как последовательность элементов `s` с индексами, равными `x = i + n * k`, где `0 <= n < (j - i) / k`. Если `k` положительно – `i` и `j` уменьшаются до `len(s)`, если превосходят `len(s)`. Если `k` отрицательно – `i` и `j` уменьшаются до `len(s) - 1`, если превосходят `len(s) - 1`. `k` не может быть равным `0`. Если `k` опущено или `None` то `k` трактуется как `1`.
5. Конкатенация иммутабельных последовательностей всегда создает новую последовательность.
6. Некоторые типы, например `range` поддерживают только последовательности, которые следуют определенным правилам, и поэтому не поддерживают конкатенацию или повторение.
7. `index` вызывает исключение `ValueError` если в последовательности нет элемента `x`.

## Иммутабельные последовательности

Иммутабельные (неизменяемые) последовательности, в отличии от мутабельных, определяют `hash(s)` по умолчанию и в следствии этого могут быть использованы как ключи для словарей (`dict` и другие), значения для параметров по умолчанию в функциях и как элементы множеств (`set` и `frozenset`).

К иммутабельным последовательностям относятся:

- `str`
- `bytes`
- `tuple`
- `range`
- `frozenset`

## Мутабельные последовательности

Для мутабельных (изменяемых) последовательностей дополнительно определены следующие операции

| Операция                   | Результат                                                                                                                  | Примечания                                                   |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `s[i] = x`                 | Заменят элемент с индексом `i` на `x`                                                                                      |                                                              |
| `s[i:j] = t`               | Заменяет slice с `i` по `j` элементами `t`                                                                                 |                                                              |
| `del s[i:j]`               | Эквивалентно `s[i:j] = []`                                                                                                 |                                                              |
| `s[i:j:k] = t`             | Заменяет элементы `s[i:j:k]` элементами `t`                                                                                | `t` должна иметь такую же длину, как и slice                 |
| `del s[i:j:k]`             | Удаляет элементы `s[i:j:k]` из последовательности                                                                          |                                                              |
| `s.append(x)`              | Добавляет x в конец последовательности                                                                                     |                                                              |
| `s.clear()`                | Удаляет все элементы из последовательности `s` (эквивалентно `del s[:]`)                                                   |                                                              |
| `s.copy()`                 | Создает копию `s` (эквивалентно `s[:]`)                                                                                    | Копируется только сама последовательность, но не ее элементы |
| `s.extend(t)` или `s += t` | Дополняет `s` содержимым `t`                                                                                               |                                                              |
| `s *= n`                   | Обновляет `s` так что содержимое повторяется `n` раз                                                                       |                                                              |
| `s.insert(i, x)`           | Вставляет `x` по индексу `i`                                                                                               |                                                              |
| `s.pop(i)`                 | Получает элемент по индексу `i` и удаляет его из последовательности. `i` – опциональный параметр, равный `-1` по умолчанию |                                                              |
| `s.remove(x)`              | Удаляет первый элемент, равный `x` из `s`                                                                                  | Вызывает `ValueError` если `s` не содержит `x`               |
| `s.reverse()`              | "Переворачивает" `s` на месте (не создает новую последовательность)                                                        |                                                              |

К мутабельным последовательностям относятся:

- `list`
- `bytearray`
- `set`
- `dict`

## 1. `tuple`

`tuple`, или кортеж – иммутабельная последовательность произвольных элементов.

Литерал – `(element1, element2, ... elementN)`, где `element1`, `element2`, `elementN` – элементы кортежа. Пустой кортеж может быть задан как `()`. Кортеж с одним элементом – как `(a, )`. Скобки – опциональны, кроме тех случаев когда надо задать пустой кортеж, или необходимы для избежания двусмысленности, например: `f(a, b)` – вызов функции с двумя аргументами, `f((a, b))` – вызов функции с одним аргументом, который является кортежем.

Конструкторы:

1. `tuple()` – возвращает пустой кортеж – `()`
2. `tuple(iterable)`, где `iterable` – итерируемый объект. Возвращает кортеж из элементов итерируемого объекта.

Примеры:

<!--
filename: chapter_9/tuple.py
-->

```python
# Использование конструктора tuple()
print(tuple())          # Выведет ()
print(tuple([1, 2, 3])) # Выведет (1, 2, 3)
print(tuple('abc'))     # Выведет ('a', 'b', 'c')

# Использование литерала
print(())               # Выведет ()
print((1, 2, 3))        # Выведет (1, 2, 3)
print(('a', 'b', 'c'))  # Выведет ('a', 'b', 'c')

# Работа с tuple

s = (1, 2, 3)
x = 4

print(x in s)     # Выведет False
print(x not in s) # Выведет True
print(len(s))     # Выведет 3
print(min(s))     # Выведет 1
print(max(s))     # Выведет 3

n = 3
t = (4, 5, 6)

# Конкатенация s и t
s = s + t
print(s)          # Выведет (1, 2, 3, 4, 5, 6)

# Повторение s n раз
print(s * n)

# Индексация
print(s[0])       # Выведет 1
print(s[1:-1])    # Выведет (2, 3, 4, 5) - срез от второго до предпоследнего элемента 
print(s[1:-1:2])  # Выведет (2, 4) - срез от второго до предпоследнего элемента с шагом 2
print(s[::-1])    # Выведет (6, 5, 4, 3, 2, 1) - срез с шагом -1 

print(s.index(x)) # Выведет 3 - индекс первого вхождения x в s
print(s.count(x)) # Выведет 1 - количество вхождений x в s
```

<!--
runs: chapter_9/tuple.py
stdout: >
    ()
    (1, 2, 3)
    ('a', 'b', 'c')
    ()
    (1, 2, 3)
    ('a', 'b', 'c')
    False
    True
    3
    1
    3
    (1, 2, 3, 4, 5, 6)
    (1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6)
    1
    (2, 3, 4, 5)
    (2, 4)
    (6, 5, 4, 3, 2, 1)
    3
    1
-->

Иммутабельность кортежа распространяется только на сам кортеж, а не на его значения (так как в Python все передается по ссылке):

<!--
filename: chapter_9/tuple_immutability.py
-->

```python
a = [1, 2, 3]
b = (a, )
print(b)
a.append(4)
print(b)
```

напечатает

<!--
runs: chapter_9/tuple_immutability.py
-->

```bash
([1, 2, 3],)
([1, 2, 3, 4],)
```

## 2. `list`

Список – изменяемая последовательность произвольных элементов

Литерал – `[element1, element2, ... elementN]`. Литерал пустого списка – `[]`

Конструкторы – аналогично кортежу:

1. `list()` – возвращает пустой список – `[]`
2. `list(iterable)`, где `iterable` – итерируемый объект. Возвращает список из элементов итерируемого объекта

Примеры:

<!--
filename: chapter_9/list.py
-->

```python
# Использование конструктора list()
print(list())          # Выведет []
print(list('abc'))     # Выведет ['a', 'b', 'c']
print(list((1, 2, 3))) # Выведет [1, 2, 3]

# Использование литерала
print([])              # Выведет []
print(['a', 'b', 'c']) # Выведет ['a', 'b', 'c']
print([1, 2, 3])       # Выведет [1, 2, 3]

# Работа с list
# Все операции с кортежем из примера выше работают и с list (т.к. все операции из примера выше определены для всех последовательностей)

s = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


# Присваивание по индексу/срезу

s[0] = 3
print(s) # Выведет [3, 2, 3, 4, 5, 6, 7, 8, 9, 10]

s[0:3] = [4, 5, 6]
print(s) # Выведет [4, 5, 6, 4, 5, 6, 7, 8, 9, 10]

s[1:-1:2] = [42, 42, 42, 42]
print(s) # Выведет [4, 42, 6, 42, 6, 42, 42, 42, 9, 10]

# Добавление элементов
s.append(42)
print(s) # Выведет [4, 42, 6, 42, 6, 42, 42, 42, 9, 10, 42]

s.insert(0, 42)
print(s) # Выведет [42, 4, 42, 6, 42, 6, 42, 42, 42, 9, 10, 42]

s += [11, 42]
print(s) # Выведет [42, 4, 42, 6, 42, 6, 42, 42, 42, 9, 10, 42, 11, 42]

# Повторим список два раза 
s *= 2
print(s) # Выведет [42, 4, 42, 6, 42, 6, 42, 42, 42, 9, 10, 42, 11, 42, 42, 4, 42, 6, 42, 6, 42, 42, 42, 9, 10, 42, 11, 42]

# Создадим копию списка. Все операции которые мы делали с s, не повлияют на s_copy
s_copy = s.copy()

# "Перевернем" список
s.reverse()
print(s) # Выведет [42, 11, 42, 10, 9, 42, 42, 42, 6, 42, 6, 42, 4, 42, 42, 11, 42, 10, 9, 42, 42, 42, 6, 42, 6, 42, 4, 42]

# Удаление элементов
del s[1::2]
print(s) # Выведет [42, 42, 9, 7, 5, 6, 4, 42, 42, 9, 7, 5, 6, 4]

del s[0:10]
print(s) # Выведет [7, 5, 6, 4]

# s.pop удаляет элемент из списка и возвращает его
print(s.pop()) # Выведет 4
print(s) # Выведет [7, 5, 6]

# s.remove удаляет первое вхождение x из списка
s.remove(6)
print(s) # Выведет [7, 5]

# s.clear очищает список
s.clear()
print(s) # Выведет []

print(s_copy) # Выведет [42, 11, 42, 10, 9, 42, 42, 42, 6, 42, 6, 42, 4, 42, 42, 11, 42, 10, 9, 42, 42, 42, 6, 42, 6, 42, 4, 42]. Копия списка не изменится
```

<!--
runs: chapter_9/list.py
stdout: >
    []
    ['a', 'b', 'c']
    [1, 2, 3]
    []
    ['a', 'b', 'c']
    [1, 2, 3]
    [3, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    [4, 5, 6, 4, 5, 6, 7, 8, 9, 10]
    [4, 42, 6, 42, 5, 42, 7, 42, 9, 10]
    [4, 42, 6, 42, 5, 42, 7, 42, 9, 10, 42]
    [42, 4, 42, 6, 42, 5, 42, 7, 42, 9, 10, 42]
    [42, 4, 42, 6, 42, 5, 42, 7, 42, 9, 10, 42, 11, 42]
    [42, 4, 42, 6, 42, 5, 42, 7, 42, 9, 10, 42, 11, 42, 42, 4, 42, 6, 42, 5, 42, 7, 42, 9, 10, 42, 11, 42]
    [42, 11, 42, 10, 9, 42, 7, 42, 5, 42, 6, 42, 4, 42, 42, 11, 42, 10, 9, 42, 7, 42, 5, 42, 6, 42, 4, 42]
    [42, 42, 9, 7, 5, 6, 4, 42, 42, 9, 7, 5, 6, 4]
    [7, 5, 6, 4]
    4
    [7, 5, 6]
    [7, 5]
    []
    [42, 4, 42, 6, 42, 5, 42, 7, 42, 9, 10, 42, 11, 42, 42, 4, 42, 6, 42, 5, 42, 7, 42, 9, 10, 42, 11, 42]
-->

## 3. `range`

Неизменяемая последовательность чисел.

Не имеет литерала.

Конструкторы:

1. `range(stop)` – вернет диапазон чисел с 0 до `stop` невключительно c шагом `1`
2. `range(start, stop, step)` – вернет диапазон чисел от `start` до `stop` невключительно с шагом `step`. Параметр `step` – опционален и по умолчанию равен 1

где `start`, `stop`, `step` – числа типа `int`

Пример:

<!--
filename: chapter_9/range.py
-->

```python
# Создадим диапазон чисел от 0 до 10 невключительно
r = range(10)
print(r) # Выведет range(0, 10)
print(list(r)) # Выведет [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Создадим диапазон чисел от 1 до 11 невключительно
r = range(1, 11)
print(r) # Выведет range(1, 11)
print(list(r)) # Выведет [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Создадим диапазон чисел от 1 до 11 невключительно с шагом 2
r = range(1, 11, 2)
print(r) # Выведет range(1, 11, 2)
print(list(r)) # Выведет [1, 3, 5, 7, 9]

# Создадим диапазон чисел от 10 до 0 невключительно с шагом -1
r = range(10, 0, -1)
print(r) # Выведет range(10, 0, -1)
print(list(r)) # Выведет [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```
