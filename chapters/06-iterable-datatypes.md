# 6. Итерируемые типы данных

Итерируемыми типами данных называют такие типы, для которых определена операция получения элемента (метод `__getitem__`, который python вызывает при использовании оператора индексации – квадратных скобок – `datatype[indexer]`) или операция получения итератора (метод `__iter__`, который python вызывает у объекта, переданного встроенной функции `iter` или в циклах или генераторах) – специального объекта, предназначенного для однократной итерации (прохода по элементам).

Подробное рассмотрение

Для всех итерируемых типов существуют операции:

| Операция     | Результат                                | Примечания |
| ------------ | ---------------------------------------- | ---------- |
| `x in s`     | `True`, если s содержит x, иначе `False` | 1          |
| `x not in s` | `False`, если s содержит x, иначе `True` | 1          |
| `len(s)`     | Длинна `s`                               |            |
| `min(s)`     | Наименьший элемент `s`                   | 2          |
| `max(s)`     | Наибольший элемент `s`                   | 2          |

Примечания:

1. Для большинства последовательностей `in` и `not in` используются для проверки того, содержит ли последовательность определенный элемент, однако для типов `str` и `bytes` эти операции проверяют, содержит ли последовательность некоторую подпоследовательность.
2. `min` и `max` вызывают исключение `ValueError` если последовательность `s` пустая.

## 1. Типы-последовательности

Для всех типов-последовательностей определены следующие операции

| Операция            | Результат                                                                                                                        | Примечания |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| `s + t`             | Конкатенация `s и t`                                                                                                             | 5, 6       |
| `s * n` или `n * s` | Конкатенация `n` последовательностей `s`                                                                                          | 1, 6       |
| `s[i]`              | `i`-тый элемент `s`                                                                                                              | 2          |
| `s[i:j]`            | Подпоследовательность с `i`-го (включительно) по `j`-ый (невключительно) элемент `s`                                             | 2, 3       |
| `s[i:j:k]`          | Подпоследовательность с `i`-го (включительно) по `j`-ый (невключительно) элемент `s` с шагом `k`                                 | 2, 4       |
| `s.index(x, i, j)`  | Самый первый индекс `x` в `s` начиная с `i` (включительно) и заканчивая `j` (невключительно). `i` и `j` – опциональные параметры | 7          |
| `s.count(x)`        | Количество `x` в `s`                                                                                                             |            |

Где `s`, `t` – последовательности; `n, i, j, k` – целые числа (типа `int`)

Примечания:

1. Значения `n`, которые меньше 0 считаются равным 0 (что приводит к получению пустой последовательности). Учтите, что элементы последовательности `s` не копируются. Полученная последовательность содержит ссылки на эти элементы.
2. `i` и `j` меньше 0 эквивалентны `len(s) - i` и `len(s) - j` соответственно. (`-0` все равно считается равным `0`). Индексация начинается с 0.
3. Эта операция называется _срез_ или _slice_. Если `i` или `j` больше `len(s)` то они уменьшаются ддо `len(s)`. Если `i` опущена (`s[i:]`) или равна `None`, то `i` трактуется как `0`. Если `о` опущена (`s[:j]`) или равна `None`, то `j` трактуется как `len(s)`. Если `i` больше или равно `j`, то slice пустой.
4. Slice от `i` до `j` с шагом `k` определен как последовательность элементов `s` с индексами, равными `x = i + n * k`, где `0 <= n < (j - i) / k`. Если `k` положительно – `i` и `j` уменьшаются до `len(s)`, если превосходят `len(s)`. Если `k` отрицательно – `i` и `j` уменьшаются до `len(s) - 1`, если превосходят `len(s) - 1`. `k` не может быть равным `0`. Если `k` опущено или `None` то `k` трактуется как `1`.
5. Конкатенация иммутабельных последовательностей всегда создает новую последовательность.
6. Некоторые типы, например `range` поддерживают только последовательности, которые следуют определенным правилам, и поэтому не поддерживают конкатенацию или повторение.
7. `index` вызывает исключение `ValueError` если в последовательности нет элемента `x`.

### Иммутабельные последовательности

Иммутабельные последовательности, в отличии от мутабельных, определяют `hash(s)` по умолчанию и в следствии этого могут быть использованы как ключи для словарей (`dict` и другие), значения для параметров по умолчанию в функциях и как элементы множеств (`set` и `frozenset`).

### Мутабельные последовательности

Для мутабельных последовательностей дополнительно определены следующие операции

| Операция                | Результат                                                                                                                  | Примечания                                                   |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `s[i] = x`              | Заменят элемент с индексом `i` на `x`                                                                                      |                                                              |
| `s[i:j] = t`            | Заменяет slice с `i` по `j` элементами `t`                                                                                 |                                                              |
| `del s[i:j`]            | Эквивалентно `s[i:j] = []`                                                                                                  |                                                              |
| `s[i:j:k] = t`          | Заменяет элементы `s[i:j:k]` элементами `t`                                                                                | `t` должна иметь такую же длину, как и slice                |
| `del s[i:j:k`]          | Удаляет элементы `s[i:j:k]` из последовательности                                                                          |                                                              |
| `s.append(x`)           | Добавляет x в конец последовательности                                                                                      |                                                              |
| `s.clear()`             | Удаляет все элементы из последовательности `s` (эквивалентно `del s[:]`)                                                   |                                                              |
| `s.copy()`              | Создает копию `s` (эквивалентно `s[:]`)                                                                                    | Копируется только сама последовательность, но не ее элементы |
| `s.extend(t) or s += t` | Дополняет `s` содержимым `t`                                                                                               |                                                              |
| `s *= n`                | Обновляет `s` так что содержимое повторяется `n` раз                                                                       |                                                              |
| `s.insert(i, x`)        | Вставляет `x` по индексу `i`                                                                                               |                                                              |
| `s.pop(i`)              | Получает элемент по индексу `i` и удаляет его из последовательности. `i` – опциональный параметр, равный `-1` по умолчанию |                                                              |
| `s.remove(x`)           | Удаляет первый элемент, равный `x` из `s`                                                                                  | Вызывает `ValueError` если `s` не содержит `x`               |
| `s.reverse()`           | "Переворачивает" `s` на месте (не создает новую последовательность)                                                        |                                                              |

### 1. `tuple`

`tuple`, или кортеж – иммутабельная последовательность произвольных элементов. Иммутабельность кортежа распространяется только на сам кортеж, а не на его значения (так как в Python все передается по ссылке):

<!--
filename: chapter_6/tuple_immutability.py
-->

```python
a = [1, 2, 3]
b = (a, )
print(b)
a.append(4)
print(b)
```

напечатает

<!--
runs: chapter_6/tuple_immutability.py
-->

```bash
([1, 2, 3],)
([1, 2, 3, 4],)
```

Литерал – `(element1, element2, ... elementN)`, где `element1`, `element2`, `elementN` – элементы кортежа. Пустой кортеж может быть задан как `()`. Кортеж с одним элементом – как `(a, )`. Скобки – опциональны, кроме тех случаев когда надо задать пустой кортеж, или необходимы для избежания двусмысленности, например: `f(a, b)` – вызов функции с двумя аргументами, `f((a, b))` – вызов функции с одним аргументом, который является кортежем.

Конструкторы:

1. `tuple()` – возвращает пустой кортеж – `()`
2. `tuple(iterable)`, где `iterable` – итерируемый объект. Возвращает кортеж из элементов итерируемого объекта

### 2. `list`

Список – изменяемая последовательность произвольных элементов

Литерал – `[element1, element2, ... elementN]`. Литерал пустого списка – `[]`

Конструкторы – аналогично кортежу:

1. `list()` – возвращает пустой список – `[]`
2. `list(iterable)`, где `iterable` – итерируемый объект. Возвращает список из элементов итерируемого объекта

### 3. `range`

Неизменяемая последовательность чисел.

Не имеет литерала.

Конструкторы:

1. `range(stop)` – вернет диапазон чисел с 0 до `stop` невключительно c шагом `1`
2. `range(start, stop, step)` – вернет диапазон чисел от `start` до `stop` невключительно с шагом `step`. Параметр `step` – опционален и по умолчанию равен 1

где `start`, `stop`, `step` – числа типа `int`

### 4. `str`

Иммутабельная строка в кодировке `utf-8`.

Литералы – `'текст строки'`, `'''текст строки'''`. Кавычки могут быть как одинарными (`'`), так и двойными (`"`). Кавычки, с которых строка начинается, должны совпадать с теми, которыми строка заканчивается. Таким образом `'текст строки"` – неверная запись. Строки с тремя кавычками (`'''`) могут занимать несколько строк в исходном коде программы. Строки с одинарными кавычками – только одну.

Конструкторы:

1. `str()` – возвращает пустую строку – `''`
2. `str(object)` – возвращает объект, преобразованный к строке.

Работа со строками будет подробно рассмотрена в одной из следующих глав.

### 5. `bytes`

Байты или bitstring (битстринг, нет принятого перевода). Литералы такие же как и у обычных строк, но с префиксом `b` (`b'bytes'`, `b'''bytes'''`). В литералах разрешены только ASCII-символы.

## 2. Типы-множества

Множества в Python – это неупорядоченные коллекции уникальных объектов.

### 1. `frozenset`

Иммутабельное множество

Не имеет литерала.

Конструкторы:

1. `frozenset()` – создает пустое множество
2. `frozenset(iterable)` – создает множество из элементов `iterable`. Каждый элемент должен быть хешируемым.

Для `frozenset` определены следующие операции:

| Операция                          | Результат                                                                                |
| --------------------------------- | ---------------------------------------------------------------------------------------- |
| `set.isdisjoint(other)`           | `True` если у `set` и `other` нет общих элементов , иначе `False`                        |
| `set.issubset(other)`             | `True` если все элементы `set` есть в `other` , иначе `False`                            |
| `set <= other`                    | Аналогично `set.issubset(other)`                                                         |
| `set < other`                     | `True` если все элементы `set` есть в `other` и `set` не равно `other` , иначе `False`   |
| `set.issuperset(other)`           | `True` если все элементы `other` есть в `set`, иначе `False`                             |
| `set >= other`                    | Аналогично `set.issuperset(other)`                                                       |
| `set > other`                     | `True` если все элементы `other` есть в `set` и `set` не равно `other`, иначе `False`    |
| `set.union(other, ...)`           | Новое множество с элементами `set` и `other`                                             |
| `set | other | ...`               | Аналогично `set.union(other, ...)`                                                       |
| `set.intersection(other, ...)`    | Новое множество с элементами которые есть в `set` и в `other`                            |
| `set & other & ...`               | Аналогично `set.intersection(other, ...)`                                                |
| `set.difference(other, ...)`      | Новое множество с элементами `set`, которых нет в `other`                                |
| `set - other - ...`               | Аналогично  `set.difference(other, ...)`                                                 |
| `set.symmetric_difference(other)` | Новое множество с элементами, которые есть только в `set` и `other`, но не в обоих сразу |
| `set ^ other`                     | Аналогично  `set.symmetric_difference(other)`                                            |
| `set.copy()`                      | Копия множества (копируется только множество, но не его элементы)                       |

Для некоторых методов определены соответствующие операторы. Аргументами операторов могут только множества, а методов – любые итерируемые объекты.

### 2. `set`

Мутабельное множество

Не имеет литерала.

Конструкторы:

1. `set()` – создает пустое множество
2. `set(iterable)` – создает множество из элементов `iterable`. Каждый элемент должен быть хешируемым.

Для `set` определены все те же операции, что и для `frozenset` и дополнительно определены следующие операции:

| Операция                                      | Результат                                                                                                     |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `set.update(other, ...)`                      | Обновляет множество, добавляя все элементы из `other`                                                         |
| `set |= other | ...`                          | Аналогично `update(other, ...)`                                                                               |
| `set.intersection_update(other, ...)`         | Обновляет множество, сохраняя только те элементы, которые встречаются в `other`                               |
| `set &= other & ...`                          | Аналогично `intersection_update(other, ...)`                                                                  |
| `set.difference_update(other, ...)`           | Обновляет множество, сохраняя только те элементы, которые не встречаются в `other`                            |
| `set -= other | ...`                          | Аналогично `difference_update(other, ...)`                                                                    |
| `set.symmetric_difference_update(other, ...)` | Обновляет множество, сохраняя только те элементы, которые есть только в `set` и `other`, но не в обоих сразу |
| `set ^= other`                                | Аналогично `symmetric_difference_update(other, ...)`                                                          |
| `set.add(elem)`                               | Добавляет элемент в множество                                                                                 |
| `set.remove(elem)`                            | Удаляет элемент из множества. Если элемента в множестве нет – вызывает `KeyError`                            |
| `set.discard(elem)`                           | Удаляет элемент из множества.                                                                                 |
| `set.pop()`                                   | Возвращает произвольный элемент множества и удаляет его из множества                                          |
| `set.clear()`                                 | Удаляет все элементы множества                                                                                |

### 3. Типы-отображения – `dict`

Мутабельный тип данных.

Представляет собой отображение хешируемых объектов в произвольные объекты.

Литерал – `{key1: value1, key2: value2, ... keyN: valueN}`. Литерал пустого словаря – `{}`.

Конструкторы:

1. `dict()` – создает пустой словарь
2. `dict(key1=value1, key2=value2, ... keyN=valueN)` – создает словарь вида `{'key1': value1, 'key2': value2, ... 'keyN': valueN}`
3. `dict(mapping, key1=value1 ...)` – создает новый словарь из существующего, добавляя или обновляя элементы словаря, переданные как опциональные именованные параметры (`key1=value1 ...`)
4. `dict(iterable, key1=value1 ...)` – создает новый словарь из итерируемого объекта, содержащего итерируемые объекты – пары ключ-значение (например, [(key1, value1), (key2, value2), ... (keyN, valueN)]), добавляя или обновляя элементы словаря, переданные как опциональные именованные параметры

Словарь – тоже итерируемый объект, и итерация происходит по ключам. В этом можно убедится при помощи конструктора `list` следующим образом:

<!--
filename: chapter_6/dict_iteration.py
-->

```python
d = {'a': 1, 'b': 2}
print(list(d))
```

<!--
runs: chapter_6/dict_iterator.py
stdout: >
    ['a', 'b']
-->

Результатом выполнения указанного выше кода будет `['a', 'b']`

Для `dict` определены следующие операции:

| Операция              | Результат                                                                                                                                                                                                          |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `d[key] = value`      | Добавляет или обновляет значение в словаре, соответствующее ключу                                                                                                                                                   |
| `del d[key]`          | Удаляет пару ключ – значении из словаря. Если ключа в словаре нет – вызывает исключение `KeyError`                                                                                                                  |
| `key in d`            | `True` если в словаре есть ключ, иначе `False`                                                                                                                                                                     |
| `key not in d`        | Эквивалентно `not key in d`                                                                                                                                                                                        |
| `d.clear()`           | Удаляет все элементы из словаря                                                                                                                                                                                    |
| `d.copy()`            | Копирует словарь (только словарь, но не его элементы)                                                                                                                                                              |
| `d.get(key, default)` | Получает значение, соответствующее ключу или `default`, если ключа в словаре нет. `default` – опциональный параметр и равен по умолчанию `None`                                                                     |
| `d.items()`           | Возвращает итерируемый объект с парами ключ-значение                                                                                                                                                               |
| `d.keys()`            | Возвращает итерируемый объект с ключами словаря                                                                                                                                                                   |
| `d.values()`          | Возвращает итерируемый объект со значениями словаря                                                                                                                                                                |
| `d.pop(key, default)` | Возвращает значение, соответствующее словарю и удаляет пару ключ-значение из словаря. Если ключа в словаре – опциональный параметр `default`. Если `default` не указан и ключа в словаре нет – вызывает `KeyError` |
| `d.popitem()`         | Возвращает пару ключ-значение и удаляет ее из словаря в порядке Last-In-First-Out                                                                                                                                  |
| `d.update(other)`     | Добавляет и обновляет пары ключ-значения парами из словаря other                                                                                                                                                   |

где `d`, `other` – словарь, `key` – ключ, `value` – значение
