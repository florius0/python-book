# 8. Классы

Мы уже говорили о том, что Python – объектно-ориентированный язык. Теперь мы рассмотрим это подробнее
Python является объектом.

## 1. Объекты

Объект – это некоторая сущность, обладающая состоянием и свойствами – аттрибутами и определяющая операции над самим собой – методы.
Объект и экземпляр класса – синонимы.

## 2. Класс

Класс – это тип объекта и одновременно "шаблон", по которому объект может быть создан. Именно в классе определены аттрибуты и свойства, которые будет иметь объект-экземпляр класса.
У каждого класса есть конструктор, который позволяет создать экземпляр объекта.

В python класс определяется следующим образом:

<!--
filename: chapter_8/class_declaration.py
-->

```python
# Ключевое слово class
#  |  Имя класса
#  |   |
class Foo:
    # Аттрибут
    bar = 1

    # Конструктор
    def __init__(self):
        # Аттрибут, доступен только у экземпляра объекта
        self.x = 0

    # Метод
    def baz(self):
        print(self.bar, self.x)

# Создаем объект при помощи вызова конструктора
f = Foo()
# Получаем значения аттрибутов объекта
print(f.bar, f.x)
# Вызываем метод объекта
f.baz()
```

<!--
runs: chapter_8/class_declaration.py
stdout: >
    1 0
    1 0
-->

### 1. Аттрибуты

#### 1. Аттрибуты объекта

Аттрибуты – это переменные, которые принадлежат объекту. В Python аттрибуты могут быть как обычными переменными, так и функциями. Все аттрибуты объекта хранятся в словаре `__dict__`, к которому можно получить доступ либо напрямую – `obj.__dict__`, либо через функцию `vars(obj)`.

Аттрибуты объекта можно создавать и удалять в любое время. Для создания аттрибута достаточно присвоить ему значение:

<!--
filename: chapter_8/instance-attributes.py
-->

```python
class Foo:
    pass

f = Foo()

# Создание аттрибута
f.bar = 42

# Получение значение аттрибута
print(f.bar)

# Удаление аттрибута
del f.bar
```

<!--
runs: chapter_8/instance-attributes.py
stdout: 42
-->

#### 2. Аттрибуты класса

Аттрибуты класса – это переменные, которые принадлежат классу, а не объекту. В Python аттрибуты класса могут быть как обычными переменными, так и функциями. Все аттрибуты класса хранятся в словаре `__dict__`, к которому можно получить доступ либо напрямую – `cls.__dict__`, либо через функцию `vars(cls)`.

Аттрибуты класса можно создавать и удалять в любое время. Для создания аттрибута достаточно присвоить ему значение:

<!--
filename: chapter_8/class-attributes.py
-->

```python
class Foo:
    pass

# Создание аттрибута
Foo.bar = 42

# Получение значение аттрибута
print(Foo.bar)
# Аттрибуты класса доступны через объекты
print(Foo().bar)

del Foo.bar
```

<!--
runs: chapter_8/class-attributes.py
stdout: >
    42
    42
-->

Важно отметить, что аттрибуты класса общие для всех объектов класса, поэтому следует быть осторожным при работе с мутабельными значениями.

Например, списками

<!--
filename: chapter_8/class-attributes-mutations.py
-->

```python
class Foo:
    bar = []
    pass

f1 = Foo()
f2 = Foo()

# Оба объекта имеют один и тот же список
print(f1.bar is f2.bar)

# Добавление элемента в список у одного объекта "повлияет" на другой (так как список на самом деле один и тот же)
f1.bar.append(42)
print(f2.bar)
```

<!--
runs: chapter_8/class-attributes-mutations.py
stdout: >
    True
    [42]
-->

Так же, если имя аттрибута объекта совпадает с именем аттрибута класса, то предпочитается аттрибуты объекта. Сначала будет выполнен поиск аттрибута в объекте, если он не будет найден, то будет выполнен поиск в классе. Если аттрибут не будет найден ни в объекте, ни в классе, то будет вызвана исключение `AttributeError`.:

<!--
filename: chapter_8/class-attributes-precedence.py
-->

```python
class Foo:
    bar = 42

f = Foo()
f.bar = 24

# Аттрибут объекта имеет приоритет над аттрибутом класса
print(f.bar)

# Удаление аттрибута объекта
del f.bar

# Теперь используется аттрибут класса
print(f.bar)
```

<!--
runs: chapter_8/class-attributes-precedence.py
stdout: >
    24
    42
-->

### 2. Методы

Методы класса – это функции, являющиеся аттрибутами класса, которые принимают первым параметром объект, для которого вызывается метод. Обычно этот параметр называется `self`.

Метод может быть вызван двумя способами:

```python
# Вызов метода через объект
f.baz()
# Вызов метода через класс
Foo.baz(f)
```

#### 1. Статические методы

Статические методы – это функции, являющиеся аттрибутами класса, но не принимающие первым параметром объект, для которого вызывается метод. При объявлении такого метода используется декоратор `@staticmethod`.

<!--
filename: chapter_8/static_method.py
-->

```python
class Foo:

    # Статический метод – не принимает первым параметром объект
    @staticmethod
    def bar():
        print('bar')

Foo.bar()
f = Foo()
f.bar()
```

<!--
runs: chapter_8/static_method.py
stdout: >
    bar
    bar
-->

Метод так же может быть вызван двумя способами, как показано выше. Обратите внимание, что при вызове метода через класс объект как аргумент не передается

#### 2. Методы класса (classmethods)

Методы класса (или класс-методы) – это функции, являющиеся аттрибутами класса, которые принимают первым параметром класс, для которого вызывается метод. При объявлении такого метода используется декоратор `@classmethod`.

Несложно заметить, что они похожи на обычные методы, но вместо объекта передается класс.

Обычно они используются для реализации фабричных методов (factory methods), как бы дополнительных конструкторов класса. Использование статических методов в таком случае нежелательно. Проиллюстрируем это на примере:

<!--
filename: chapter_8/class_method.py
-->

```python
class Foo:

    # Класс-метод для создания объектов
    @classmethod
    def bar(cls):
        return cls()

    # Cтатический метод для создания объектов
    @staticmethod
    def baz():
        return Foo()

# Класс-наследник
class Bar(Foo):
    pass


f = Foo.bar()
b = Bar.bar()

print('Using classmethod:')
print(isinstance(f, Foo))
print(isinstance(f, Bar))

print(isinstance(b, Foo))
print(isinstance(b, Bar))

f = Foo.baz()
b = Bar.baz()

print('Using staticmethod:')
print(isinstance(f, Foo))
print(isinstance(f, Bar))

print(isinstance(b, Foo))
print(isinstance(b, Bar))
```

В результате получим:

<!-- 
runs: chapter_8/class_method.py
-->

```bash
Using classmethod:
True
False
True
True
Using staticmethod:
True
False
True
False
```

Функция `isinstance` возвращает `True`, если объект является экземпляром класса или его подкласса (подробнее об этом в разделе про наследование).
И как мы видим, в классе `Bar` (наследнике класса `Foo`) вызов метода `bar` через класс-метод возвращает объект класса `Bar`, а вызов метода `baz` через статический метод возвращает объект класса `Foo`.

### 3. Наследование

Наследование – это механизм, позволяющий создавать новые классы на основе уже существующих. Новый класс называется наследником (потомком, подклассом) базового класса (родителя, суперкласса). В унаследованном классе можно переопределить методы базового класса, добавить новые методы и атрибуты. При этом в наследнике можно использовать методы и атрибуты базового класса, а также добавить новые.

#### 1. Единичное наследование

Для того, чтобы создать новый класс на основе существующего, нужно указать в круглых скобках после имени класса родительский класс. Например, класс `Bar` наследуется от класса `Foo`:

<!-- 
filename: chapter_8/single_inheritance.py
-->

```python
class Foo:
    def foo(self):
        print('foo')

class Bar(Foo):
    def foo(self):
        super().foo()
        print('bar')

class Baz(Bar):
    def foo(self):
        super().foo()
        print('baz')

Foo().foo()
print()
Bar().foo()
print()
Baz().foo()
```

Для того, чтобы получить базовые аттрибуты и методы из класса-наследника, можно использовать функцию `super()`. Это позволяет избежать прямого обращения к базовому классу, что может быть полезно, если в будущем базовый класс изменится.

В результате получим:

<!--
runs: chapter_8/single_inheritance.py
-->

```bash
foo

foo
bar

foo
bar
baz
```

#### 2. Множественное наследование

В Python можно наследовать класс от нескольких родительских классов. Например, класс `Bar` наследуется от классов `Foo` и `Baz`:

<!--
filename: chapter_8/multiple_inheritance.py
-->

```python
class Foo:
    def foo(self):
        print('foo')

class Baz:
    def baz(self):
        print('baz')

class Bar(Foo, Baz):
    def foo(self):
        super().foo()
        print('bar')

    def baz(self):
        super().baz()
        print('bar')

Bar().foo()
print()
Bar().baz()
```

В результате получим:

<!--
runs: chapter_8/multiple_inheritance.py
-->

```bash
foo
bar

baz
bar
```

##### Порядок разрешения методов

При наследовании от нескольких классов возможна такая ситуация, что один и тот же метод определен в нескольких родительских классах. В этом случае Python будет искать метод в порядке (как при использовании функции `super`, так и при вызове непереопределенного метода), в котором указаны родительские классы.
Посмотреть порядок разрешения методов можно с помощью функции `mro()`:

<!--
filename: chapter_8/method_resolution_order.py
-->

```python
class Foo:
    def foo(self):
        print('foo')

class Baz:
    def foo(self):
        print('baz')

class FooBaz(Foo, Baz):
    def foo(self):
        super().foo()
        print('foo baz')

class BazFoo(Baz, Foo):
    def foo(self):
        super().foo()
        print('baz foo')

FooBaz().foo()
print()
BazFoo().foo()
```

В результате получим:

<!--
runs: chapter_8/method_resolution_order.py
-->

```bash
foo
foo baz

baz
baz foo
```

### 5. Модификаторы доступа

В Python нет явных модификаторов доступа, но есть соглашение, которое позволяет определить, какие аттрибуты и методы являются публичными, а какие — приватными.

Аттрибуты и методы, которые начинаются с двух подчеркиваний `__`, считаются приватным на уровне имени класса. То есть, к таким аттрибутам и методам можно обращаться только из методов этого класса.

Непубличными являются также аттрибуты и методы, которые начинаются с одного подчеркивания `_`. Однако, к таким аттрибутам и методам можно обращаться из методов классов-наследников.

Все прочие методы и аттрибуты считаются публичными.

### 6. Специальные методы

В Python есть множество специальных методов, которые позволяют переопределить поведение классов. Например, метод `__init__` вызывается при создании экземпляра класса, а метод `__str__` — при преобразовании экземпляра класса в строку.

Список всех специальных методов можно посмотреть в <https://docs.python.org/3/reference/datamodel.html#special-method-names>.
