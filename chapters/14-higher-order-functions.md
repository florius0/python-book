# 14. Функции высшего порядка и рекурсия

## 1. Функции высшего порядка

Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов или возвращают функции в качестве результата. Ниже мы рассмотрим некоторые функции высшего порядка в Python.

### 1. reduce

Перед использованием `reduce` необходимо импортировать из модуля `functools`:

```python
from functools import reduce
```

`reduce` принимает два аргумента: функцию и последовательность. Функция должна принимать два аргумента. Первый аргумент - это аккумулятор, который хранит промежуточный результат. Второй аргумент - это текущий элемент последовательности. `reduce` применяет функцию к аккумулятору и текущему элементу последовательности, а затем сохраняет результат в аккумуляторе. После того, как все элементы последовательности будут обработаны, `reduce` вернет аккумулятор в качестве результата.

Опциональным третьим аргументом может быть начальное значение аккумулятора. Если начальное значение не указано, то первый элемент последовательности будет использован в качестве начального значения аккумулятора, а второй элемент последовательности будет использован в качестве первого аргумента функции.

<!--
filename: chapter_14/reduce.py
-->

```python
from functools import reduce

print(reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]))
```

<!--
runs: chapter_14/reduce.py
stdout: 15
-->

Видно, что результатом работы вышепреведенного фрагмента будет `15`.

Функция reduce является аналогом цикла `for`:

<!-- 
filename: chapter_14/reduce_for.py
-->

```python
x, *l = [1, 2, 3, 4, 5]
for y in l:
    x += l

print(x)
```

<!--
runs: chapter_14/reduce_for.py
stdout: 15
-->

### 2. sum

Функция `sum` принимает последовательность и возвращает сумму всех элементов последовательности:

<!-- 
filename: chapter_14/sum.py
-->

```python
print(sum([1, 2, 3, 4, 5]))
```

<!--
runs: chapter_14/sum.py
stdout: 15
-->

Опциональным вторым аргументом функции `sum` может быть начальное значение аккумулятора:

<!-- 
filename: chapter_14/sum_start.py
-->

```python
sum([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]], [])
```

<!--
runs: chapter_14/sum_start.py
stdout: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
-->

Пример использования `sum` выше можно использовать для уплощенния (flatten) списка списков в один список.

Функция `sum` – менее _мощная_, нежели `reduce`. Это значит, что `sum` может быть выражена через `reduce`:

<!--
filename: chapter_14/sum_reduce.py
-->

```python
def sum(l, start=0):
    return reduce(lambda x, y: x + y, l, start)

print(sum([1, 2, 3, 4, 5]))
```

### 3. map

Функция `map` принимает два аргумента: функцию и последовательность. Функция должна принимать один аргумент. `map` применяет функцию к каждому элементу последовательности и возвращает новую последовательность, содержащую результаты применения функции к каждому элементу последовательности.

Возвращенная последовательность является итератором. Чтобы получить ее элементы, необходимо "пройти" этот итератор. Например привести итератор к списку:

<!--
filename: chapter_14/map.py
-->

```python
x = map(lambda x: x + 1, [1, 2, 3, 4, 5])

print(list(x))
```

<!--
runs: chapter_14/map.py
stdout: [2, 3, 4, 5, 6]
-->

### 3. filter

Функция `filter` принимает два аргумента: функцию и последовательность. Функция должна принимать один аргумент – конкретный . `filter` применяет функцию к каждому элементу последовательности и возвращает новую последовательность, содержащую только те элементы, для которых функция вернула `True`.

Аналогично `map`, `filter` возвращает последовательность в виде итератора.

<!--
filename: chapter_14/filter.py
-->

```python
x = filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5])

print(list(x))
```

<!--
runs: chapter_14/filter.py
stdout: [2, 4]
-->

### 4. zip

Функция `zip` принимает две последовательности и возвращает последовательность-итератор кортежей, содержащих элементы из обеих последовательностей.

<!--
filename: chapter_14/zip.py
-->

```python
x = zip([1, 2, 3, 4, 5], [6, 7, 8, 9, 10])

print(list(x))
```

<!--
runs: chapter_14/zip.py
stdout: [(1, 6), (2, 7), (3, 8), (4, 9), (5, 10)]
-->

### 5. sorted

Функция `sorted` принимает последовательность и возвращает отсортированную последовательность-итератор. По умолчанию сортировка происходит по возрастанию. Для сортировки по убыванию необходимо передать аргумент `reverse=True`. Так же опциональным параметром `key` можно передать функцию-ключ, на основе значений которой для каждого жэлемента будет происходить сортировка.

<!--
filename: chapter_14/sorted.py
-->

```python
x = sorted([5, 4, 3, 2, 1])
y = sorted([1, 2, 3, 4, 5], reverse=True)
z = sorted([(1, 3), (2, 5), (3, 7), (4, 3), (5, 10)], key=lambda x: x[0] * x[1])

print(list(x))
print(list(y))
print(list(z))
```

<!--
runs: chapter_14/sorted.py
stdout: > 
[1, 2, 3, 4, 5]
[5, 4, 3, 2, 1]
[(1, 3), (4, 3), (2, 5), (3, 7), (5, 10)]
-->

Все рассмотренные нами функции возвращают итераторы, а не последовательности того типа, которые были переданы в качестве аргументов. Это сделано для того, чтобы не создавать лишних объектов в памяти и производить вычисления только тогда, когда их результат будет необходим.

## 2. Рекурсия

Рекурсия – это вызов функции из самой себя. Рекурсивная функция должна иметь условие выхода, иначе она будет вызывать сама себя бесконечно.

<!-- 
filename: chapter_14/recursive.py
-->

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))
```

<!--
runs: chapter_14/recursive.py
stdout: 120
-->

В Python, в отличии от большинства функциональных языков глубина рекурсии ограничена 1000 вызовами:

<!--
filename: chapter_14/recursive_limit.py
-->

```python
def f(n):
    if n == 0:
        return 0
    else:
        return f(n - 1)

f(1000)
print(1000)

try:
    f(1001)
    print(1001)
except RecursionError:
    print('RecursionError')
```

<!--
runs: chapter_14/recursive_limit.py
stdout: >
1000
RecursionError
-->

Эта функция вызовет ошибку `RecursionError: maximum recursion depth exceeded in comparison` при `n > 1000`.
Лимит глубины рекурсии можно изменить, передав в функцию `sys.setrecursionlimit` новое значение.

<!--
filename: chapter_14/recursive_limit_increased.py
-->

```python
import sys
sys.setrecursionlimit(2000)

def f(n):
    if n == 0:
        return 0
    else:
        return f(n - 1)

f(1001)
```

<!--
runs: chapter_14/recursive_limit_increased.py
-->

Так же, любая рекурсивная функция может быть переписана с помощью цикла.

<!--
filename: chapter_14/recursive_to_loop.py
-->

```python
def factorial(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

print(factorial(5))
```

<!--
runs: chapter_14/recursive_to_loop.py
stdout: 120
-->

Хотя и рекурсия является более чистым способом представления алгоритма, чем цикл, в большинстве случаев рекурсия работает медленнее, чем цикл.
