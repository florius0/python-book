# 4. Переменные и типы данных

В прошлой главе мы работали со строками, но в `Python` так же существют и другие типы данных, работу с которыми мы рассмотрим в этой главе.

Так же в прошлой главе мы упоминали литералы. Литерал – это способ записи (нотация) для обозначния фиксированного значения в исходном коде программы.

## 1. `bool`

У этого типа данных есть только 2 значения-литерала: `True` и `False`

Так же для этого типа (и тех типов, которые могут быть приведины к `bool`) определены следующие операции

| Операция  | Название       | Результат                                  |
| --------- | -------------- | ------------------------------------------ |
| `x or y`  | Логическое или | Если `x` равно `True` то `y` иначе `x`     |
| `x and y` | Логическое и   | Если `x` равно `False` то `x` иначе `y`    |
| `not x`   | Логическое не  | Если `x` равно `False` то `True` иначе `y` |

## 2. Численные типы

Эти типы данных преднозначены для представления различных чисел. Для каждого из них определены следующие операции.

| Операция | Название              | Примечания                                  |
| -------- | --------------------- | ------------------------------------------- |
| `x + y`  | Сложение              |                                             |
| `x - y`  | Вычитание             |                                             |
| `x * y`  | Умножение             |                                             |
| `x / y`  | Деление               |                                             |
| `x % y`  | Остаток от деления    | `x % y = x - n * y`, где `n = x // y`       |
| `x // y` | Целочисленное деление | Округленное к минус бесконечноти `x / y`    |
| `x ** y` | Возведение в степень  | В Python как и в других языках `0 ** 0 = 1` |
| `-x`     | Отрицание             | Меняет знак числа на противоположный        |
| `+x`     |                       | Не изменяет знак числа                      |

### 1. `int`

Значения этого типа – произвольные целые числа (любой длинны, в отличии от некоторых других языков). Литералы могут содержать цифры `0`-`9`, символы `a` - `f` и `A` - `F` (могут быть использованы только если число задано в шестнадцетиричной системе исчесления), знак `-` (самым первым символом), префиксы `0b`, `0o`, `0x`, обозначающие, что число будет записано в двоичной, восьмеричной и шестнадйатиричной системе исчисления соответствеено.

Примеры целых чисел, заданых литералами:

| Литерал             | Значение (в десятичной системе исчесления) | Примечания                                                                |
| ------------------- | ------------------------------------------ | ------------------------------------------------------------------------- |
| `1234567890`        | `1234567890`                               |                                                                           |
| `-1234567890`       | `-1234567890`                              |                                                                           |
| `001`               | `1`                                        | Незначащие цифры опускаются                                               |
| `0b101`             | `5`                                        | Число в двоичной системе исчесления                                       |
| `-0b101`            | `-5`                                       | Числа в не-дестичной системе исчесления тоже могу быть отрицательными     |
| `0b00101`           | `5`                                        | Незначащие цифры опускаются и для числа в не-дестичной системе исчесления |
| `0o1234567`         | `342391`                                   | Число в восьмеричной системе исчесления                                   |
| `0x123456789abcdef` | `81985529216486895`                        | Число в шестнадтцетиричной системе исчесления                             |
| `0x123456789ABCDEF` | `81985529216486895`                        | Цифры `A-F` могут быть обозначены как большими, так и маленькими буквами  |

Так же только для чисел типа `int` определены следующие побитовые операци:

| Операция | Результат                                 |
| -------- | ----------------------------------------- |
| `x \| y` | Побитовое или `x` и `y`                   |
| `x ^ y`  | Исключающее побитовое или (xor) `x` и `y` |
| `x & y`  | Побитовое и `x` и `y`                     |
| `x << n` | Побитовой сдвиг `x` на `n` влево          |
| `x >> y` | Побитовой сдвиг `x` на `n` вправо         |

### 2. `float`

Значени этого типа – числа с плавающей точкой. Точность ограничена 64 битами. Числа типа float реализованы в соответствии с [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754).
float-литералы могут содержать цифры `0`-`9`, десятичный разделитель `.`, знак `-` (самым первым символом), суффикс вида `e<x>` или `E<x>` ([scientifc notation](https://en.wikipedia.org/wiki/Scientific_notation)), где `<x>` – целочисленный литерал. Этот суффиккс означает, что число умножено на 10 в степени `x`.

Примеры чисел с плавающей точкой, заданных литералами

| Литерал  | Значение | Примечания                                                                                |
| -------- | -------- | ----------------------------------------------------------------------------------------- |
| `1.0`    | `1.0`    |                                                                                           |
| `-1.0`   | `-1.0`   |                                                                                           |
| `0.1`    | `0.1`    |                                                                                           |
| `1.`     | `1.0`    | Незначащий 0 после точки можно опкускать                                                  |
| `.1`     | `0.1`    | Незначащий 0 до точки можно опускать                                                      |
| `1.23e2` | `123.0`  | Эквивалентно `1.23 * 10 ** 2`                                                             |
| `123e-2` | `1.23`   | Эквивалентно `123 * 10 ** -2`. Если используется `e<x>`, то `.` в литерале можно опускать |

### 3. `complex`

Тип для представления комплексных чисел. Литерал – `<re>+<im>j` или `<re>-<im>j` в заввисимости от знака перед мнимой частью. `<re>` и `<im>` – float-литералы, вещественная и мнимая части соответственно.

Примеры комплексных чисел, заданных литералами

| Литерал    | Значение      | Примечания                     |
| ---------- | ------------- | ------------------------------ |
| `1+2j`     | `(1+2j)`      |                                |
| `1-2j`     | `(1-2j)`      |                                |
| `1.0+2.0j` | `(1+2j)`      | `.` можно опускать             |
| `1e5+0j`   | `(100000+2j)` | Допустимы любые float-литералы |
| `.1+.1j`   | `(.1+.1j)`    | Допустимы любые float-литералы |

## 3. Итерируемые типы

### 1. Типы-последовательности

Для всех типов-последовательностей определены следующие операции

| Операция            | Результат                                                                                                                        | Примечания |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| `x in s`            | `True`, если s содержит x, иначе `False`                                                                                         | 1          |
| `x not in s`        | `False`, если s содержит x, иначе `True`                                                                                         | 1          |
| `s + t`             | Конкатенация `s и t`                                                                                                             | 6, 7       |
| `s * n` или `n * s` | Конкатенация `n` последовательнотей `s`                                                                                          | 2, 7       |
| `s[i]`              | `i`-тый элемент `s`                                                                                                              | 3          |
| `s[i:j]`            | Подпоследовательность с `i`-го (включительно) по `j`-ый (невключительно) элемент `s`                                             | 3, 4       |
| `s[i:j:k]`          | Подпоследовательность с `i`-го (включительно) по `j`-ый (невключительно) элемент `s` с шагом `k`                                 | 3, 5       |
| `len(s)`            | Длинна `s`                                                                                                                       |            |
| `min(s)`            | Наименьший элемент `s`                                                                                                           | 9          |
| `max(s)`            | Наибольший элемент `s`                                                                                                           | 9          |
| `s.index(x, i, j)`  | Самый первый индекс `x` в `s` начиная с `i` (включительно) и заканчивая `j` (невключительно). `i` и `j` – опциональные параметры | 8          |
| `s.count(x)`        | Количество `x` в `s`                                                                                                             |            |

Где `s`, `t` – последовательности; `n, i, j, k` – целыые числа (типа `int`)

Примечания:

1. Для большинства последовательностей `in` и `not in` используются для проверки того, содержит ли последовательность определенный элемент, однако для типов `str` и `bytes` эти операции проверют, содержит ли последовательность некоторую подпоследовательность.
2. Значения `n`, которые меньше 0 считаются равным 0 (что приводит к получению пустой последдовательности). Учтите, что элементы последовательности `s` не копируются. Полученная последовательность содержит ссылки на эти элементы.
3. `i` и `j` меньше 0 эквивалентны `len(s) - i` и `len(s) - j` соответственно. (`-0` все равно считается равным `0`). Индексация начинается с 0.
4. Эта операция называется _срез_ или _slice_. Если `i` или `j` больше `len(s)` то они уменьшаются ддо `len(s)`. Если `i` опущена (`s[i:]`) или равна `None`, то `i` трактуется как `0`. Если `о` опущена (`s[:j]`) или равна `None`, то `j` трактуется как `len(s)`. Если `i` больше или равно `j`, то slice пустой.
5. Slice от `i` до `j` с шагом `k` определен как последовательность элементов `s` с индедксами, равными `x = i + n * k`, где `0 <= n < (j - i) / k`. Если `k` положительно – `i` и `j` уменьшаются до `len(s)`, если превосходят `len(s)`. Если `k` отрицательно – `i` и `j` уменьшаются до `len(s) - 1`, если превосходят `len(s) - 1`. `k` не может быть равным `0`. Если `k` опущено или `None` то `k` трактуется как `1`.
6. Конкатенация иммутабельных последовательностей всегда создает новую последовательность.
7. Некоторые типы, например `range` поддерживают только последовательности, которые следуют определенным правилам, и поэтому не поддерживают конкатенацию или повторение.
8. `index` вызывает исключение `ValueError` если в последовательности нет элемента `x`.
9. `min` и `max` вызывают исключение `ValueError` если последовательность `s` пустая.

#### Иммутабельные последовательности

Иммутабельные последовательности, в отличии от мутабельных, определяют `hash(s)` по умолчанию и в следствии этого могут быть использованы как ключи для словарей (`dict` и другие), значения для параметров по умолчанию в функциях и как элементы множеств (`set` и `frozenset`).

#### Мутабельные последовательности

Для мутабельных последовательностей дополнительно определены следующие операции

| Операция                | Результат                                                                                                                  | Примечания                                     |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| `s[i] = x`              | Заменят элемент с индексом `i` на `x`                                                                                      |                                                |
| `s[i:j] = t`            | Заменяет slice с `i` по `j` элементами `t`                                                                                 |                                                |
| `del s[i:j`]            | Эквивалетно `s[i:j] = []`                                                                                                  |                                                |
| `s[i:j:k] = t`          | Заменяет элементы `s[i:j:k]` элементами `t`                                                                                | `t` должна иметь такую же длинну, как и slice  |
| `del s[i:j:k`]          | Удаляет элементы `s[i:j:k]` из последовательности                                                                          |                                                |
| `s.append(x`)           | Добаляет x в конец последовательности                                                                                      |                                                |
| `s.clear()`             | Удаляет все элементы из последовательности `s` (эквивалентно `del s[:]`)                                                   |                                                |
| `s.copy()`              | Создает копию `s` (эквивалентно `s[:]`)                                                                                    |                                                |
| `s.extend(t) or s += t` | Дополняет `s` содержимым `t`                                                                                               |                                                |
| `s *= n`                | Обновляет `s` так что содержимое повторяется `n` раз                                                                       |                                                |
| `s.insert(i, x`)        | Вставляет `x` по индексу `i`                                                                                               |                                                |
| `s.pop(i`)              | Получает элемент по индексу `i` и удаляет его из последовательности. `i` – опциональный параметр, равный `-1` по умолчанию |                                                |
| `s.remove(x`)           | Удаляет первый элемент, равный `x` из `s`                                                                                  | Вызывает `ValueError` если `s` не содержит `x` |
| `s.reverse()`           | "Переворачивает" `s` на месте (не создает новую последовательность)                                                        |                                                |

#### 1. `tuple`

`tuple`, или кортеж – иммутабельная последовательность произвольных элементов. Учтите, что иммутабельность кортежа распостраняется только на сам кортеж, а не на его значения (так как в Python все передается по ссылке):

<!--
filename: chapter_4/tuple_immutability.py
-->

```python
a = [1, 2, 3]
b = (a, )
print(b)
a.append(4)
print(b)
```

напечатает

<!--
runs: chapter_4/tuple_immutability.py
-->

```bash
([1, 2, 3],)
([1, 2, 3, 4],)
```

Литерал – `(element1, element2, ... elementN)`, где `element1`, `element2`, `elementN` – элементы кортежа. Пустой кортеж может быть задан как `()`. Кортеж с одним элементом – как `(a, )`. Скобки – опциональны, кроме тех случаев когда надо задать пустой кортеж, или необходимы для избежания двусмысленности, например: `f(a, b)` – вызов функции с двумя аргументами, `f((a, b))` – вызов функции с одним аргументом, который является кортежем.

#### 2. `list`

Список – изменяемая последовательность произвольных элементов

Литерал – `[element1, element2, ... elementN]`. Литерал пустого списка – `[]`

#### 3. `range`

Неизменяемая последовательность чисел.

Задается при помощи конструктора:

1. `range(stop)` – вернет диапазон чисел с 0 до `stop` невключительно c шагом `1`
2. `range(start, stop, step)` – вернет диапазон чисел от `start` до `stop` невключительно с шагом `step`. Параметр `step` – опционален и по умолчанию равен 1

где `start`, `stop`, `step` – числа типа `int`

#### 4. `str`

Иммутабельная строка в кодировке `utf-8`.

Литералы – `'текст строки'`, `'''текст строки'''`. Кавычки могут быть как одинарными (`'`), так и двойными (`"`). Кавычки, с которых строка начинается, должны совпадать с теми, которыми строка заканчивается. Таким образом `'текст строки"` – неверная запись. Строки с тремя кавычками (`'''`) могут занимать несколько строк в исходном кодде программы. Строки с одинарными кавычками – только одну.

#### 5. `bytes`

Байты или bitstring (битстринг, нет принятого перевода). Литералы такие же как и у обычных строк, но с префисом `b` (`b'bytes'`, `b'''bytes'''`). В литералах разрешены только ASCII-символы.

### 2. Типы-множества

#### 1. `set`

#### 2. `frozenset`

### 3. `dict`

## Задания

Напишите программы:

1. Для решения квадратных и кубических уравнений (с комплексными корнями)
2. Которая печатает перевернутую введенную строку
3. Которая печатает каждый второй символ введенной строки
4. Которая печатает символы введенной строи со второго по предпоследний и длинны исходной и полученной строки
