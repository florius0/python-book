# 16. Пакет NumPy

В этой главе мы рассмотрим библиотеку NumPy, которая предоставляет эффективные реализации многомерных массивов и функций для работы с ними. Мы рассмотрим, как создавать массивы, какие операции можно выполнять с ними, и какие функции можно применять к ним. Мы также рассмотрим, как можно использовать массивы для представления векторов и матриц, и как можно выполнять с ними математические операции.

## 1. Установка

Для установки пакета NumPy введите следующую команду:

```bash
python3 -m pip install numpy
```

При импорте пакета NumPy обычно импортируют его под сокращенным именем `np`:

```python
import numpy as np
```

Далее мы будем использовать сокращенное имя `np`, там, где это имеет смысл.

## 2. Создание массивов

Массивы в NumPy представляют собой многомерные массивы, которые могут содержать элементы одного типа. Так как NumPy предназначен для быстрой работы с массивами, предпочтительно использовать типы данных, которые предоставляет NumPy:

| Тип данных               | Описание                                                                |
| ------------------------ | ----------------------------------------------------------------------- |
| `np.half`/`np.float16`   | 16-битное число с плавающей точкой                                      |
| `np.single`/`np.float32` | 32-битное число с плавающей точкой                                      |
| `np.double`/`np.float64` | 64-битное число с плавающей точкой                                      |
| `np.longdouble`          | число с плавающей точкой с увеличенной точностью (зависит от платформы) |
| `np.csingle`             | Комплексное число из двух `np.single`                                   |
| `np.cdouble`             | Комплексное число из двух `np.double`                                   |
| `np.clongdouble`         | Комплексное число из двух `np.longdouble`                               |

NumPy предоставляет и другие типы данных, но обычно они используются редко, и мы не будем их рассматривать.

Помимо типов данных NumPy, в качестве типа данных массива можно использовать любой тип данных.

Для создания массивов в NumPy существует несколько функций:

1. `np.zeros(shape, dtype=float, order='C')` – создает массив, заполненный нулями. Параметр `shape` задает размерность массива и может быть либо целым числом, тогда массив будет одномерным, либо кортежем из целых чисел, тогда массив будет многомерным и его размерность будет соответствовать размерноси кортежа, а длинна по каждому "измерению" – соответствующему числу в кортеже. Параметр `dtype` задает тип данных массива. Параметр `order` – порядок хранения элементов в памяти, доступные варианты: `'C'` – тогда элементы хранятся по строкам и `'F'` – элементы хранятся по столбцам.
2. `np.ones` – аналог `np.zeroes`, только заполняет массив единицами, а не нулями.
3. `np.array(array_like_obj, dtype=float, order='C')` – служит для преобразования объектов в массивы NumPy. Параметр `array_like_object` может быть списком, кортежем, массивом NumPy или другим объектом, который можно преобразовать в массив NumPy. Параметры `dtype` и `order` имеют те же значения, что и в `np.zeros` и `np.ones`.
4. `np.diag(values, k=0)` – создает массив, заполненный элементами из `values` на диагонали и нулями в остальных элементах. Параметр `k` задает смещение диагонали относительно главной диагонали. Если `k` положительное, то диагональ смещена вверх, если отрицательное – вниз. Если `values` одномерный, то диагональ будет равна `values`, если двумерный, то диагональ будет равна k-ой диагонали `values`.
5. `np.eye(N, M=None, k=0, dtype=float, order='C')` – создает массив-единичную матрицу. Параметр `N` задает количество строк, а `M` – количество столбцов. Если `M` не задан, то `M=N`. Параметры `dtype` и `order` имеют те же значения, что и в `np.zeros` и `np.ones`. Параметр `k` – аналогично `np.diag`.
6. `np.arange(start, stop, step, dtype=None)` – создает массив, заполненный последовательностью чисел, начиная с `start` и заканчивая `stop` с шагом `step`. Параметр `dtype` аналогичен `np.zeros`. Если `dtype` не задан, то тип элементов массива будет `int` или `float`, в зависимости от того, является ли `start`, `stop` или `step` числом с плавающей точкой.
7. `np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)` – создает массив, заполненный последовательностью чисел, начиная с `start` и заканчивая `stop` с равным шагом. Параметр `num` задает количество элементов в массиве. Если `endpoint` равен `True`, то `stop` включается в массив, иначе – нет. Если `retstep` равен `True`, то возвращается кортеж, в котором первый элемент – массив, а второй – шаг. Параметр `dtype` аналогичен `np.фкфтп`.
8. `np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)` – создает массив, заполненный последовательностью чисел, начиная с `base` в степени `start` и заканчивая `base` в степени `stop` с равным шагом в логарифмической шкале. Прочие параметры аналогичны `np.linspace`.

Пример:

<!--
filename: chapter_16/numpy_array_creation.py
-->

```python
import numpy as np

# Создание массива из нулей
print(np.zeros((2, 3)))                          # [[0. 0. 0.]
                                                #  [0. 0. 0.]]

print(np.zeros(5, dtype=int))                    # [0 0 0 0 0]

# Создание массива из единиц

print(np.ones((2, 3)))                           # [[1. 1. 1.]
                                                #  [1. 1. 1.]]

print(np.ones(5, dtype=int))                     # [1 1 1 1 1]

# Создание массива из списка списков

print(np.array([[1, 2, 3], [4, 5, 6]]))          # [[1 2 3]
                                                #  [4 5 6]]

# Создание массива по диагонали
print(np.diag([1, 2, 3]))                        # [[1 0 0]
                                                #  [0 2 0]
                                                #  [0 0 3]]

print(np.diag([1, 2, 3], k=1))                   # [[0 1 0 0]
                                                #  [0 0 2 0]
                                                #  [0 0 0 3]
                                                #  [0 0 0 0]]

# Создание единичной матрицы
print(np.eye(3))                                 # [[1. 0. 0.]
                                                #  [0. 1. 0.]
                                                #  [0. 0. 1.]]

print(np.eye(3, M=5, k=1))                       # [[0. 1. 0. 0. 0.]
                                                #  [0. 0. 1. 0. 0.]
                                                #  [0. 0. 0. 1. 0.]]

# Создание массива из последовательности чисел
print(np.arange(5))                              # [0 1 2 3 4]
print(np.arange(5, 10))                          # [5 6 7 8 9]
print(np.arange(5, 10, 2))                       # [5 7 9]

# Создание массива из последовательности чисел с равным шагом
print(np.linspace(0, 10, num=5))                 # [ 0.   2.5  5.   7.5 10. ]

print(np.linspace(0, 10, num=5, endpoint=False)) # [0. 2. 4. 6. 8.]

# Создание массива из последовательности чисел с равным шагом в логарифмической шкале

print(np.logspace(0, 5, num=5))                  # [1.00000000e+00 3.16227766e+01 1.00000000e+03 3.16227766e+04
                                                 #  1.00000000e+05]

print(np.logspace(0, 10, 5, base=2))             # [ 1.  2.  4.  8. 16.]
```

<!--
runs: chapter_16/numpy_array_creation.py
stdout: >
    [[0. 0. 0.]
     [0. 0. 0.]]
    [0 0 0 0 0]
    [[1. 1. 1.]
     [1. 1. 1.]]
    [1 1 1 1 1]
    [[1 2 3]
     [4 5 6]]
    [[1 0 0]
     [0 2 0]
     [0 0 3]]
    [[0 1 0 0]
     [0 0 2 0]
     [0 0 0 3]
     [0 0 0 0]]
    [[1. 0. 0.]
     [0. 1. 0.]
     [0. 0. 1.]]
    [[0. 1. 0. 0. 0.]
     [0. 0. 1. 0. 0.]
     [0. 0. 0. 1. 0.]]
    [0 1 2 3 4]
    [5 6 7 8 9]
    [5 7 9]
    [ 0.   2.5  5.   7.5 10. ]
    [0. 2. 4. 6. 8.]
    [1.00000000e+00 3.16227766e+01 1.00000000e+03 3.16227766e+04
     1.00000000e+05]
    [ 1.  2.  4.  8. 16.]
-->

## 3. Сохранение и загрузка массивов

NumPy позволяет сохранять и загружать массивы в файл разными способами. Мы рассмотрим сохранение и загрузку массивов в текстовые файлы в формате csv при помощи `np.genfromtxt` и `np.savetxt`, так как они наиболее часто используемые и содержат меньше подводных камней.
Помимо этих функций, так же можно использовать `np.load` и `np.save` для сохранения и загрузки массивов в бинарном формате.

1. `np.genfromtxt(fname, dtype=float, delimeter=None)` – считывает массив из текстового файла. Параметр `fname` задает имя файла (путь относительно запущенного `.py`-файла или текущей директории). Параметр `dtype` аналогичен `np.zeros`. Параметр `delimeter` задает разделитель элементов в строке. Если `delimeter` не задан, то разделителем считается любое количество пробельных символов.

2. `np.savetxt(fname, X, delimiter=' ')` – сохраняет массив `X` в текстовый файл. Параметр `fname` задает имя файла аналогично `np.genfromtxt`. Параметр `delimiter` – разделитель.

Пример:

<!--
filename: chapter_16/numpy_array_saving_loading.py
-->

```python
import numpy as np

# Сохранение массива в текстовый файл
a = np.array([[1, 2, 3], [4, 5, 6]])
np.savetxt('a.txt', a)

# Загрузка массива из текстового файла
b = np.genfromtxt('a.txt')
print(b)    # [[1. 2. 3.]
            #  [4. 5. 6.]]

# Сохранение массива в текстовый файл с другим разделителем
np.savetxt('a.txt', a, delimiter=',')

# Загрузка массива из текстового файла с другим разделителем
b = np.genfromtxt('a.txt', delimiter=',')
print(b)    # [[1. 2. 3.]
            #  [4. 5. 6.]]
```

<!--
runs: chapter_16/numpy_array_saving_loading.py
stdout: >
    [[1. 2. 3.]
     [4. 5. 6.]]
    [[1. 2. 3.]
     [4. 5. 6.]]
-->

## 4. Индексация и срезы

NumPy позволяет индексировать массивы похожим образом, как и списки в Python. Индексация многомерных массивов может быть записана в виде `a[i][j]..` (так же, как мы бы индексировали многоуровневый список списков) или `a[i, j, ...]`.
Эти две записи полностью эквивалентны друг другу.

Пример:

<!--
filename: chapter_16/numpy_indexing.py
-->

```python
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]])
print(a[0, 0])   # 1
print(a[0][0])   # 1

print(a[1:, 1:]) # [[5 6]]
print(a[:, 1])   # [2 5]
print(a[1, :])   # [4 5 6]
```

<!--
runs: chapter_16/numpy_indexing.py
stdout: >
    1
    1
    [[5 6]]
    [2 5]
    [4 5 6]
-->

В отличии, от Python, NumPy позволяет индексировать массивы не только целыми числами, но и другими массивами (и array-like объектами). Тогда возвращается массив той же размерности, что и индексирующий массив, и каждый элемент этого массива является элементом исходного массива, индекс которого соответствует индексу в индексирующем массиве. В случае многомерного массива, для каждого измерения должен быть передан свой индексирующий массив.

Индексирующий массив так же может быть типа `bool`. Тогда индексирование будет эквивалентно следующему выражению: `a[b.nonzero()]`. Метод `nonzero()` возвращает кортеж массивов индексов элементов (по одному на каждое измерение), которые не равны нулю.

Пример:

<!--
filename: chapter_16/numpy_indexing_with_array.py
-->

```python
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]])
b = np.array([[False, True, False],
              [True, False, True]])

c = np.array([0, 1])

print(a[b])    # [2 4 6]
print(a[c])    # [[1 2 3]
               #  [4 5 6]]

print(a[c, c]) # [1 5]
```

## 5. Манипуляции с массивами

1. `a.T` или `a.transpose()` – транспонирование массива. Возвращает новый массив, транспонированный по отношению к исходному. Транспонирование – это замена строк на столбцы и наоборот.
2. `a.reshape(shape)` – изменение размерности массива. Возвращает новый массив, размерность которого соответствует переданному кортежу `shape`. Количество элементов в исходном массиве должно совпадать с количеством элементов в новом массиве.
3. `a.resize(shape)` – изменение размерности массива. Количество элементов в исходном массиве может не совпадать с количеством элементов в новом массиве, тогда в исходном массиве будут удалены лишние элементы или добавлены новые элементы, заполненные нулями.
4. `np.append(a, b, axis=None)` – добавление элементов в массив. Возвращает новый массив, в который добавлены элементы массива `b` в конец массива `a`. Если указан параметр `axis`, то элементы массива `b` добавляются в массив `a` по указанной оси (для многомерных массивов).
5. np.insert(arr, obj, values, axis=None) – вставка элементов в массив. Возвращает новый массив, в который вставлены элементы массива `values` в массив `arr` перед индексом `obj`. Если указан параметр `axis`, то элементы массива `values` вставляются в массив `arr` по указанной оси (для многомерных массивов). Параметр `obj` может быть целым числом или кортежем целых чисел или срезом.
6. `np.delete(arr, obj, axis=None)` – удаление элементов из массива. Возвращает новый массив, из которого удалены элементы массива `arr` по индексу `obj`. Параметры аналогичны `np.insert`.
7. `np.concatenate((a1, a2, ...), axis=0)` – объединение массивов. Возвращает новый массив, в котором по указанной оси объединены массивы `a1`, `a2`, ... Количество элементов в каждом массиве должно совпадать по всем остальным осям, кроме указанной.
8. `np.hstack` и `np.vstack` аналогичны `np.concatenate` с параметром `axis=0` и `axis=1` соответственно.
9. `np.split(ary, indices_or_sections, axis=0)` – разделение массива на несколько массивов. Возвращает список массивов, в которых разделен массив `ary` по указанной оси. Если параметр `indices_or_sections` является целым числом, то массив разделяется на равные части. Если параметр `indices_or_sections` является списком целых чисел, то массив разделяется по указанным индексам.
10. `np.hsplit` и `np.vsplit` аналогичны `np.split` с параметром `axis=0` и `axis=1` соответственно.

Пример:

<!--
filename: chapter_16/numpy_array_manipulation.py
-->

```python
import numpy as np

a = np.array(np.arange(12).reshape(3, 4))

print(a)

print(np.transpose(a))

print(a.T)
print(a.T.T)

a.resize((3, 5))

print(a)

print(np.append(a, [[1, 2, 3, 4, 5]], axis=0))

print(np.insert(a, 1, 5, axis=1))

print(np.delete(a, 1, axis=1))

print(np.concatenate((a, a), axis=0))

print(np.hstack((a, a)))

print(np.vstack((a, a)))

print(np.split(a, 3, axis=0))

print(np.split(a, [1, 3], axis=1))

print(np.hsplit(a, 2))

print(np.vsplit(a, 3))
```

<!--
runs: chapter_16/numpy_array_manipulation.py
stdout: >
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
    [[ 0  4  8]
     [ 1  5  9]
     [ 2  6 10]
     [ 3  7 11]]
    [[ 0  4  8]
     [ 1  5  9]
     [ 2  6 10]
     [ 3  7 11]]
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
    [[ 0  1  2  3  0]
     [ 4  5  6  7  0]
     [ 8  9 10 11  0]]
    [[ 0  1  2  3  0]
     [ 4  5  6  7  0]
     [ 8  9 10 11  0]
     [ 1  2  3  4  5]]
    [[ 0  5  1  2  3  0]
     [ 4  5  6  7  0  0]
     [ 8  5  9 10 11  0]]
    [[ 0  1  2  3  0]
     [ 4  6  7  0  0]
     [ 8  9 10 11  0]]
    [[ 0  1  2  3  0]
     [ 4  5  6  7  0]
     [ 8  9 10 11  0]
     [ 0  1  2  3  0]
     [ 4  5  6  7  0]
     [ 8  9 10 11  0]]
    [[ 0  1  2  3  0  0  1  2  3  0]
     [ 4  5  6  7  0  0  5  6  7  0]
     [ 8  9 10 11  0  0  9 10 11  0]]
    [[ 0  1  2  3  0]
     [ 4  5  6  7  0]
     [ 8  9 10 11  0]
     [ 0  1  2  3  0]
     [ 4  5  6  7  0]
     [ 8  9 10 11  0]]
    [array([[0, 1, 2, 3, 0]]), array([[4, 5, 6, 7, 0]]), array([[ 8,  9, 10, 11,  0]])]
    [array([[0],
           [4],
           [8]]), array([[1, 2],
           [5, 6],
           [9, 10]]), array([[ 3,  0],
           [ 7,  0],
           [11,  0]])]
    [array([[0, 1, 2, 3, 0],
           [4, 5, 6, 7, 0]]), array([[ 8,  9, 10, 11,  0]])]
    [array([[0, 1, 2, 3, 0],
           [4, 5, 6, 7, 0]]), array([[8, 9, 10, 11, 0]]), array([[0, 1, 2, 3, 0]])]
-->

## 6. Математические операции

NumPy предоставляет множество математических функций, которые можно применять к массивам. Большинство этих функций являются векторизованнымми (vectorized) и могут применяться к массивам, как к элементарным объектам. Векторизованные функции работают быстрее, чем циклы, поэтому их следует использовать вместо циклов, если это возможно.

### 1. Арифметика

Основные арифметические операции, которые можно применять к массивам, это сложение, вычитание, умножение и деление. Операции выполняются поэлементно, то есть каждый элемент массива участвует в операции с соответствующим элементом другого массива. Если массивы имеют разные размеры, то NumPy пытается привести их к одинаковому размеру, выполняя необходимые преобразования.

В следующем примере мы создаем два массива, а затем выполняем над ними различные арифметические операции.

<!--
filename: chapter_16/numpy_arithmetic.py
-->

```python
import numpy as np

a = np.array([1, 2, 3, 4])
b = np.array([10, 20, 30, 40])

print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a // b)
print(a % b)
print(a ** b)
```

### 2. Линейная алгебра

Функкции NumPy для линейной алгебры расположены в модуле `numpy.linalg`. В этом модуле реализованы функции для выполнения основных операций линейной алгебры, таких как решение систем линейных уравнений, вычисление определителя, вычисление собственных значений и т.д.

1. `np.linalg.dot(a, b)` — скалярное произведение матрицы `a` на матрицу `b`.
2. `np.linalg.matmul(a, b)` – матричное произведение матрицы `a` на матрицу `b`.
3. `np.linalg.norm(a)` — норма матрицы `a`.
4. `np.linalg.det(a)` — определитель матрицы `a`.
5. `np.linalg.inv(a)` — обратная матрица к матрице `a`.
6. `np.linalg.solve(a, b)` — решение системы линейных уравнений `a * x = b`.
7. `np.linalg.trace(a)` — cktl матрицы `a`.

Помимо вышеуказанных, в модуле `numpy.linalg` реализованы еще множество других функций, которые можно посмотреть в [документации](https://numpy.org/doc/stable/reference/routines.linalg.html).

Пример:

<!--
filename: chapter_16/numpy_linalg.py
-->

```python
import numpy as np

a = np.array([[1, 2], [3, 4]])
b = np.array([[10, 20], [30, 40]])

print(np.linalg.dot(a, b))
print(np.linalg.matmul(a, b))
print(np.linalg.norm(a))
print(np.linalg.det(a))
print(np.linalg.inv(a))
print(np.linalg.solve(a, b))
print(np.linalg.trace(a))
```

<!--
runs: chapter_16/numpy_linalg.py
stdout: >
    [[ 70 100]
     [150 220]]
    [[ 70 100]
     [150 220]]
    5.477225575051661
    -2.0000000000000004
    [[-2.   1. ]
     [ 1.5 -0.5]]
    [[-2.00000000e+01  1.00000000e+01]
     [ 1.50000000e+01 -5.55111512e-17]]
    5
-->

### 3. Сравнения

NumPy предоставляет функции для выполнения сравнений элементов массивов. Все эти функции возвращают массив булевых значений, в котором `True` соответствует элементу, который удовлетворяет условию, а `False` — элементу, который не удовлетворяет условию. Если массив сравнивается с массивом, то сравнение выполняется поэлементно. Если массив сравнивается с числом (не-массивом в общем случае), то сравнение выполняется с каждым элементом массива.

По скольку сравнения возвращают массив булевых значений, то для получения элементов, которые удовлетворяют условию, можно использовать индексацию.

Пример:

<!--
filename: chapter_16/numpy_comparison.py
-->

```python
import numpy as np

a = np.array([1, 2, 3, 4, 5])
b = np.array([5, 4, 3, 4, 5])

print(a == b)
print(a != b)

print(a < b)
print(a <= b)

print(a > b)
print(a >= b)

print(a[a < b])

print(a < 5)
print(a[a < 5])
```

<!--
runs: chapter_16/numpy_comparison.py
stdout: >
    [False False  True False  True]
    [ True  True False  True False]
    [ True  True False False False]
    [ True  True  True False  True]
    [False False  True  True False]
    [False False  True  True  True]
    [1 2 3 4]
    [ True  True  True  True False]
    [1 2 3 4]
-->

### 4. Агрегирование

NumPy предоставляет функции для выполнения агрегирования элементов массивов. Все эти функции возвращают одно число, которое является результатом агрегирования.

1. `sum` — сумма элементов массива.
2. `prod` — произведение элементов массива.
3. `mean` — среднее значение элементов массива.
4. `std` — стандартное отклонение элементов массива.
5. `var` — дисперсия элементов массива.
6. `min` — минимальное значение элементов массива.
7. `max` — максимальное значение элементов массива.

Пример:

<!--
filename: chapter_16/numpy_aggregation.py
-->

```python
import numpy as np

a = np.array([1, 2, 3, 4, 5])

print(np.sum(a))
print(np.prod(a))
print(np.mean(a))
print(np.std(a))
print(np.var(a))
print(np.min(a))
print(np.max(a))
```

<!--
runs: chapter_16/numpy_aggregation.py
stdout: >
    15
    120
    3.0
    1.4142135623730951
    2.0
    1
    5
-->

### 5. Сортировка

NumPy предоставляет функции для выполнения сортировки элементов массивов. Все эти функции возвращают отсортированный массив.

1. `sort` — сортировка элементов массива.
2. `argsort` — получение индексов элементов массива, отсортированных в соответствии с исходным массивом.

Пример:

<!--
filename: chapter_16/numpy_sort.py
-->

```python
import numpy as np

a = np.array([5, 2, 3, 1, 4])

print(np.sort(a))
print(np.argsort(a))
```

<!--
runs: chapter_16/numpy_sort.py
stdout: >
    [1 2 3 4 5]
    [3 1 2 4 0]
-->

## 7. Применение функций к массиву

Для того чтобы написать функцию, которая будет применяться к каждому элементу массива, можно использовать декоратор `np.vectorize`. Он оборачивает функцию, которая принимает один аргумент–элемент массива и возвращает новый элемент, в соответствующие циклы `for`:

<!--
filename: chapter_16/numpy_vectorize.py
-->

```python
import numpy as np

@np.vectorize
def f(x):
    return x * random.random()

def g(x)
    return x * random.random()

a = np.array([1, 2, 3, 4, 5])

print(f(a))
print(g(a))
```

Следует отметить, что `np.vectorize` не является оптимальным способом применения функции к массиву. По возможности стоит использовать уже векторизованные функции из библиотеки `numpy` и строить собственную функцию как их композицию.
