# 7. Функции

Мы уже познакомились с функциями `print` и `input`. В этой главе мы подробно рассмотрим создание и использование функций в Python.

Функция – это блок кода, который возвращает какое-либо значение при вызове и принимает 0 или больше аргументов.

## 1. Синтаксис вызова функции

Синтаксис вызова выглядит следующим образом: `function_name(список аргументов функции)`, где `function_name` – имя функции. Cписок аргументов функции будет рассмотрен вместе с синтаксисом объявления функции.

## 2. Синтаксис объяления функции

Функция в коде программы определяется следующим образом:

```python
@decorator1(arg)
@decorator2
...
@decoratorN
def functon_name(
    arg1: arg1_type_annotation,
    arg2: arg2_type_annotation,
    ...,
    argN: argN_type_annotation,
    *args: args_type_annotation,
    kwarg2=v2: kwarg2_type_annotation, 
    kwarg1=v1: kwarg1_type_annotation,
    ..., 
    kwargN=vN: kwargN_type_annotation, 
    **kwargs: kwargs_type_annotation) -> retun_type_annotation:
    # тело функции
    return something
```

где
`@decorator1`, `@decorator2`, `@decoratorN` – декораторы функции,
`def` – ключевое слово для объявления функции,
`function_name` – имя функции,
все, что между скобками – список параметров функции,
`..._type_annotation` – аннотации типов как аргументов, так и возвращаемого значения,
`# тело функции` – блок-тело функции, к которому относится и `return something`
`return` – ключевое слово для возвращения значения из функции,
`something` – выражение, значение которого будет возвращено.

Большинство конструкций (кроме `def`, `function_name` и тела функции) из вышепреведенного определения являются опциональными, что дает нам возможность разобрать определение функции на примерах возрастающей сложности.

При интерпритации определения функции имя функции в текущем локальном пространстве именя связывается с объектом функции, который является оберткой над исполняемым кодом функции и содержит ссылку на текущее глобальное пространство имен, которое будет использовано при вызове функции.

Тело функции выполняется только в момент вызова.

### 1. Минимальное определение функции

Так как декораторы, список параметров и аннотации типов, а так же `return` являются опциональными получаем следующее определение функции:

<!-- 
filename: chapter_7/minimal_function_definition.py
-->

```python
# определение
def f():
    pass

# вызов функции
print(f())
```

Для того, чтобы вызвать функцию запишем `f()` – имя функции и список аргументов функции в скобках. По скольку функция принимает 0 параметров, список аргументов будет пустым.

Запустим получившуюся программу и увидим:

<!--
runs: chapter_7/minimal_function_definition.py
-->

```bash
None
```

### 2. Возвращение результата из функции. `return`

Как уже было указано ранее, функции в Python всегда возвращают какое-либо значение, даже если оно не указано явно. Мы наблюдали это в предидущем примере.

Разберем, как работает `return`.
Существуют два варианта записи: `return _expression_`, которая возвращает значение выражения `_expression_` и `return`, которая эквивалентна `return None`.

Если в теле функкции отсутствует ключевое слово `return`, то функция возвращает `None`.

Так же выполнение `return` во время выполнения тела функции вызывает завершение выполнения тела функции

Пример:

<!--
filename: chapter_7/return_from_function.py
-->

```python
def f1():
    pass

def f2():
    return
    print('Никогда не будет выполнено')

def f3():
    return None

def g1():
    return 42

def g2():
    return 40 + 2

print(f1(), f2(), f3())
print(f1() == f2() == f3() == None)

print(g1(), g2())
print(g1() == g2() == 42)
```

Мы объявили функции `f1`, `f2`, `f3`, которые возввращают `None`, функцию `g1`, которая возвращает целое число 42 и функцию `g2`, которая так же возвращает 42, но уже вычисляет его как 40 + 2.

Так же в функции `f2` продемонстрировно "прерывающее свойство" `return`

В результате выполнения программы увидим

<!--
runs: chapter_7/return_from_function.py
-->

```bash
None None None
True
42 42
True
```

### 3. Параметры функции

Для начала определим, что такое параметры функции и аргументы функции.
Параметр функции – это имя переменной, которую мы можем использовать внутри функции, и которая будет связана со значением, переданным в функцию – аргументом.
Например,

<!-- 
filename: chapter_7/args_and_parameters.py
-->

```python
def f(a, b, c):
    return a + b + c

print(f(1, 2, 3))
```

`def f(a, b, c)...` определяет функцию `f` с тремя параметрами: `a`, `b` и `c`, `f(1, 2, 3)` – вызывает функцию `f` с параметрами `1`, `2` и `3`. Соответственно, в теле функции `a = 1`, `b = 2`, `c = 3`.

Несложно заметить, что если мы запустим этот пример, то увидим следующее

<!--
runs: chapter_7/args_and_parameters.py
-->

```bash
6
```

Способы передачи аргументов:

#### 1. Позиционные аргументы

Передаются в виде выражений, разделенных запятыми: `f(1, 2, 3)`

#### 2. Именованные аргументы

Передаются в виде `имя=выражения`, так же разделяются запятыми: `f(a=1, b=2, c=3)`

Именнованые аргументы могут быть переданы только после позиционных. Таким образом запись `f(1, b=2, 3)` – синтаксически не верна

В Python существует несколько типо параметров:

#### 1. Позиционные или именованные

Тип параметров по умолчанию. Указывают аргументы, который может быть передан либо позиционно, либо по имени

Пример:

<!-- 
filename: chapter_7/args_positional_and_keyword.py
runs: chapter_7/args_positional_and_keyword.py
stdout: "True\n"
-->

```python
def f(a, b, c=0):
    return a + b + c

print(f(1, 2, 3) == f(1, 2, c=3) == f(1, b=2, c=3) == f(a=1, b=2, c=3))
```

#### 2. Только позиционные

Указывают аргументы, который может быть передан только позиционно. В списке параметров функции отделяются от последующих параметров символом `/`

Пример:

<!-- 
filename: chapter_7/args_positional_only.py
runs: chapter_7/args_positional_only.py
stdout: "6\n"
-->

```python
def f(a, b, c, /):
    return a + b + c

print(f(1, 2, 3))
```

#### 3. Только именованные

Указывают аргумент, который может быть передан только через ключевое слово. В списке параметров функции отделяются от предидущих параметров символом `*`

Пример:

<!-- 
filename: chapter_7/args_keyword_only.py
runs: chapter_7/args_keyword_only.py
stdout: "6\n"
-->

```python
def f(*, a, b, c):
    return a + b + c

print(f(a=1, b=2, c=3))
```

#### 4. Переменное число позиционных параметров

Указывают последовательность аргументов произвольной длинныы, которая может быть передана позиционно (в дополнении к другим позиционным аргументам, если такие есть). В списке параметров может быть объявлен с использованием префикса `*` только один раз после всех позиционных параметров. В теле функции значение параметра будет являтся кортежом из соответствующих аргументов.

Пример:

<!-- 
filename: chapter_7/args_varargs.py
runs: chapter_7/args_varargs.py
stdout: "True\n"
-->

```python
def f(a, *args):
    return a + sum(args)

print(f(1, 2, 3) == f(1, 1, 2, 2) == f(2, 2, 2) == f(1, 1, 1, 1, 1, 1) == f(6))
```

#### 5. Переменное число именованных параметров

Указывают произвольное количество аргументов, которые могут быть переданы по имени (в дополнении к другим именованным аргументам, если такие есть). В списке параметров может быть объявлен с использованием префикса `**` только один раз после всех именованных параметров. В теле функции значение параметра будет являятся словарем вида `{'parameter_name': parameter_value}` из соответствующих аргументов.

Пример:

<!-- 
filename: chapter_7/args_varkwargs.py
runs: chapter_7/args_varkwargs.py
stdout: "True\n"
-->

```python
def f(arg, **kwargs):
    return arg + sum(kwargs.values())

print(f(1, a=2, b=3) == f(1, c=1, d=2, e=2) == f(2, f=2, g=2) == f(1, k=1, m=1, n=1, l=1, o=1) == f(6))
```

Как видно из вышепреведенных примеров, параметр `param`, заданныый в виде `param=value` имеет значение по умолчанию `value` и передача аргумента является необязательной. Значение по умолчанию вычисляется только один раз при интерпритации определения функции. И это значение используется при каждом вызове функции, что может привести к неожиданным результатам, если значение по умолчанию – мутабельный объект. Python не запрещает использование мутабельных значений по умолчанию, но это не рекомендуется.

Пример такого неожиданного результата:

<!-- 
filename: chapter_7/args_default.py
runs: chapter_7/args_default.py
stdout: |
    [1]
    [1, 1]
    ['str']
-->

```python
def make_list(value, a=[]):
    a.append(value)
    return a

def empty_list(b=[]):
    return b

print(make_list(1)) # ожидаем [1], получаем [1]
print(make_list(1)) # ожидаем [1], получаем [1, 1], так как значение a внутри make_list изменилось

# аналогичная ситуация, но тут уже мы "руками" поменяли значение b
empty_list().append('str')
print(empty_list())
```

### 4. Аннотации типов

### 5. Декораторы
